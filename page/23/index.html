<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> Movle</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="https://img-blog.csdnimg.cn/20200609161448519.jpg" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="https://img-blog.csdnimg.cn/2020060916514052.png" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Movle</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['种一棵树，最好的时机是十年前，其次是现在', '人必有痴，而后有成', '今天，我没有浑浑噩噩的度过'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-Kafka之Consumer配置信息"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/02/02/Kafka%E4%B9%8BConsumer%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/"
    >Kafka之Consumer配置信息</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/02/02/Kafka%E4%B9%8BConsumer%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/" class="article-date">
  <time datetime="2019-02-02T12:50:00.000Z" itemprop="datePublished">2019-02-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Kafka/">Kafka</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="1-Kafka之Consumer配置信息"><a href="#1-Kafka之Consumer配置信息" class="headerlink" title="1.Kafka之Consumer配置信息"></a>1.Kafka之Consumer配置信息</h4><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">默认值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">group.id</td>
<td align="center"></td>
<td align="center">Consumer的组ID，相同goup.id的consumer属于同一个组</td>
</tr>
<tr>
<td align="center">zookeeper.connect</td>
<td align="center"></td>
<td align="center">Consumer的zookeeper连接串，要和broker的配置一致。</td>
</tr>
<tr>
<td align="center">consumer.id</td>
<td align="center">null</td>
<td align="center">如果不设置会自动生成。</td>
</tr>
<tr>
<td align="center">socket.timeout.ms</td>
<td align="center">30 * 1000</td>
<td align="center">网络请求的socket超时时间。实际超时时间由max.fetch.wait + socket.timeout.ms 确定</td>
</tr>
<tr>
<td align="center">socket.receive.buffer.bytes</td>
<td align="center">64 * 1024</td>
<td align="center">The socket receive buffer for network requests.</td>
</tr>
<tr>
<td align="center">fetch.message.max.bytes</td>
<td align="center">1024 * 1024</td>
<td align="center">查询topic-partition时允许的最大消息大小。consumer会为每个partition缓存此大小的消息到内存，因此，这个参数可以控制consumer的内存使用量。这个值应该至少比server允许的最大消息大小大，以免producer发送的消息大于consumer允许的消息</td>
</tr>
<tr>
<td align="center">num.consumer.fetchers</td>
<td align="center">1</td>
<td align="center">The number fetcher threads used to fetch data.</td>
</tr>
<tr>
<td align="center">auto.commit.enable</td>
<td align="center">true</td>
<td align="center">如果此值设置为true，consumer会周期性的把当前消费的offset值保存到zookeeper。当consumer失败重启之后将会使用此值作为新开始消费的值。</td>
</tr>
<tr>
<td align="center">auto.commit.interval.ms</td>
<td align="center">60 * 1000</td>
<td align="center">Consumer提交offset值到zookeeper的周期。</td>
</tr>
<tr>
<td align="center">queued.max.message.chunks</td>
<td align="center">2</td>
<td align="center">用来被consumer消费的message chunks 数量， 每个chunk可以缓存fetch.message.max.bytes大小的数据量。</td>
</tr>
<tr>
<td align="center">auto.commit.interval.ms</td>
<td align="center">60 * 1000</td>
<td align="center">Consumer提交offset值到zookeeper的周期</td>
</tr>
<tr>
<td align="center">queued.max.message.chunks</td>
<td align="center">2</td>
<td align="center">用来被consumer消费的message chunks 数量， 每个chunk可以缓存fetch.message.max.bytes大小的数据量</td>
</tr>
<tr>
<td align="center">fetch.min.bytes</td>
<td align="center">1</td>
<td align="center">The minimum amount of data the server should return for a fetch request. If insufficient data is available the request will wait for that much data to accumulate before answering the request.</td>
</tr>
<tr>
<td align="center">fetch.wait.max.ms</td>
<td align="center">100</td>
<td align="center">The maximum amount of time the server will block before answering the fetch request if there isn’t sufficient data to immediately satisfy fetch.min.bytes.</td>
</tr>
<tr>
<td align="center">rebalance.backoff.ms</td>
<td align="center">2000</td>
<td align="center">Backoff time between retries during rebalance.</td>
</tr>
<tr>
<td align="center">refresh.leader.backoff.ms</td>
<td align="center">200</td>
<td align="center">Backoff time to wait before trying to determine the leader of a partition that has just lost its leader.</td>
</tr>
<tr>
<td align="center">auto.offset.reset</td>
<td align="center">largest</td>
<td align="center">What to do when there is no initial offset in ZooKeeper or if an offset is out of range ;smallest : automatically reset the offset to the smallest offset; largest : automatically reset the offset to the largest offset;anything else: throw exception to the consumer</td>
</tr>
<tr>
<td align="center">consumer.timeout.ms</td>
<td align="center">-1</td>
<td align="center">若在指定时间内没有消息消费，consumer将会抛出异常。</td>
</tr>
<tr>
<td align="center">exclude.internal.topics</td>
<td align="center">true</td>
<td align="center">Whether messages from internal topics (such as offsets) should be exposed to the consumer.</td>
</tr>
<tr>
<td align="center">zookeeper.session.timeout.ms</td>
<td align="center">6000</td>
<td align="center">ZooKeeper session timeout. If the consumer fails to heartbeat to ZooKeeper for this period of time it is considered dead and a rebalance will occur.</td>
</tr>
<tr>
<td align="center">zookeeper.connection.timeout.ms</td>
<td align="center">6000</td>
<td align="center">The max time that the client waits while establishing a connection to zookeeper.</td>
</tr>
<tr>
<td align="center">zookeeper.sync.time.ms</td>
<td align="center">2000</td>
<td align="center">How far a ZK follower can be behind a ZK leader</td>
</tr>
</tbody></table>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kafka/" rel="tag">Kafka</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Kafka之Producer配置信息"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/02/02/Kafka%E4%B9%8BProducer%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/"
    >Kafka之Producer配置信息</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/02/02/Kafka%E4%B9%8BProducer%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/" class="article-date">
  <time datetime="2019-02-02T09:50:00.000Z" itemprop="datePublished">2019-02-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Kafka/">Kafka</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="1-Kafka之Producer配置信息"><a href="#1-Kafka之Producer配置信息" class="headerlink" title="1.Kafka之Producer配置信息"></a>1.Kafka之Producer配置信息</h4><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">默认值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">metadata.broker.list</td>
<td align="center"></td>
<td align="center">启动时producer查询brokers的列表，可以是集群中所有brokers的一个子集。注意，这个参数只是用来获取topic的元信息用，producer会从元信息中挑选合适的broker并与之建立socket连接。格式是：host1:port1,host2:port2</td>
</tr>
<tr>
<td align="center">request.required.acks</td>
<td align="center">0</td>
<td align="center">参见3.2节介绍</td>
</tr>
<tr>
<td align="center">request.timeout.ms</td>
<td align="center">10000</td>
<td align="center">Broker等待ack的超时时间，若等待时间超过此值，会返回客户端错误信息。</td>
</tr>
<tr>
<td align="center">producer.type</td>
<td align="center">sync</td>
<td align="center">同步异步模式。async表示异步，sync表示同步。如果设置成异步模式，可以允许生产者以batch的形式push数据，这样会极大的提高broker性能，推荐设置为异步。</td>
</tr>
<tr>
<td align="center">serializer.class</td>
<td align="center">kafka.serializer.DefaultEncoder</td>
<td align="center">序列号类，.默认序列化成byte[]</td>
</tr>
<tr>
<td align="center">key.serializer.class</td>
<td align="center"></td>
<td align="center">Key的序列化类，默认同上</td>
</tr>
<tr>
<td align="center">partitioner.class</td>
<td align="center">kafka.producer.DefaultPartitioner</td>
<td align="center">Partition类，默认对key进行hash。</td>
</tr>
<tr>
<td align="center">compression.codec</td>
<td align="center">none</td>
<td align="center">指定producer消息的压缩格式，可选参数为： “none”, “gzip” and “snappy”。关于压缩参见4.1节</td>
</tr>
<tr>
<td align="center">compressed.topics</td>
<td align="center">null</td>
<td align="center">启用压缩的topic名称。若上面参数选择了一个压缩格式，那么压缩仅对本参数指定的topic有效，若本参数为空，则对所有topic有效。</td>
</tr>
<tr>
<td align="center">message.send.max.retries</td>
<td align="center">3</td>
<td align="center">Producer发送失败时重试次数。若网络出现问题，可能会导致不断重试。</td>
</tr>
<tr>
<td align="center">retry.backoff.ms</td>
<td align="center">100</td>
<td align="center">Before each retry, the producer refreshes the metadata of relevant topics to see if a new leader has been elected. Since leader election takes a bit of time, this property specifies the amount of time that the producer waits before refreshing the metadata</td>
</tr>
<tr>
<td align="center">topic.metadata.refresh.interval.ms</td>
<td align="center">600 * 1000</td>
<td align="center">The producer generally refreshes the topic metadata from brokers when there is a failure (partition missing, leader not available…). It will also poll regularly (default: every 10min so 600000ms). If you set this to a negative value, metadata will only get refreshed on failure. If you set this to zero, the metadata will get refreshed after each message sent (not recommended). Important note: the refresh happen only AFTER the message is sent, so if the producer never sends a message the metadata is never refreshed</td>
</tr>
<tr>
<td align="center">queue.buffering.max.ms</td>
<td align="center">5000</td>
<td align="center">启用异步模式时，producer缓存消息的时间。比如我们设置成1000时，它会缓存1秒的数据再一次发送出去，这样可以极大的增加broker吞吐量，但也会造成时效性的降低。</td>
</tr>
<tr>
<td align="center">queue.buffering.max.messages</td>
<td align="center">10000</td>
<td align="center">采用异步模式时producer buffer 队列里最大缓存的消息数量，如果超过这个数值，producer就会阻塞或者丢掉消息。</td>
</tr>
<tr>
<td align="center">queue.enqueue.timeout.ms</td>
<td align="center">-1</td>
<td align="center">当达到上面参数值时producer阻塞等待的时间。如果值设置为0，buffer队列满时producer不会阻塞，消息直接被丢掉。若值设置为-1，producer会被阻塞，不会丢消息。</td>
</tr>
<tr>
<td align="center">batch.num.messages</td>
<td align="center">200</td>
<td align="center">采用异步模式时，一个batch缓存的消息数量。达到这个数量值时producer才会发送消息</td>
</tr>
<tr>
<td align="center">send.buffer.bytes</td>
<td align="center">100 * 1024</td>
<td align="center">Socket write buffer size</td>
</tr>
<tr>
<td align="center">client.id</td>
<td align="center">“”</td>
<td align="center">The client id is a user-specified string sent in each request to help trace calls. It should logically identify the application making the request.</td>
</tr>
</tbody></table>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kafka/" rel="tag">Kafka</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Kafka之Broker配置信息"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/02/02/Kafka%E4%B9%8BBroker%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/"
    >Kafka之Broker配置信息</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/02/02/Kafka%E4%B9%8BBroker%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/" class="article-date">
  <time datetime="2019-02-02T08:50:00.000Z" itemprop="datePublished">2019-02-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Kafka/">Kafka</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="1-Kafka之Broker配置信息"><a href="#1-Kafka之Broker配置信息" class="headerlink" title="1.Kafka之Broker配置信息"></a>1.Kafka之Broker配置信息</h4><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">默认值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">broker.id</td>
<td align="center"></td>
<td align="center">必填参数，broker的唯一标识</td>
</tr>
<tr>
<td align="center">log.dirs</td>
<td align="center">/tmp/kafka-logs</td>
<td align="center">Kafka数据存放的目录。可以指定多个目录，中间用逗号分隔，当新partition被创建的时会被存放到当前存放partition最少的目录。</td>
</tr>
<tr>
<td align="center">port</td>
<td align="center">9092</td>
<td align="center">BrokerServer接受客户端连接的端口号</td>
</tr>
<tr>
<td align="center">zookeeper.connect</td>
<td align="center">null</td>
<td align="center">Zookeeper的连接串，格式为：hostname1:port1,hostname2:port2,hostname3:port3。可以填一个或多个，为了提高可靠性，建议都填上。注意，此配置允许我们指定一个zookeeper路径来存放此kafka集群的所有数据，为了与其他应用集群区分开，建议在此配置中指定本集群存放目录，格式为：hostname1:port1,hostname2:port2,hostname3:port3/chroot/path 。需要注意的是，消费者的参数要和此参数一致。</td>
</tr>
<tr>
<td align="center">message.max.bytes</td>
<td align="center">1000000</td>
<td align="center">服务器可以接收到的最大的消息大小。注意此参数要和consumer的maximum.message.size大小一致，否则会因为生产者生产的消息太大导致消费者无法消费。</td>
</tr>
<tr>
<td align="center">num.io.threads</td>
<td align="center">8</td>
<td align="center">服务器用来执行读写请求的IO线程数，此参数的数量至少要等于服务器上磁盘的数量。</td>
</tr>
<tr>
<td align="center">queued.max.requests</td>
<td align="center">500</td>
<td align="center">I/O线程可以处理请求的队列大小，若实际请求数超过此大小，网络线程将停止接收新的请求。</td>
</tr>
<tr>
<td align="center">socket.send.buffer.bytes</td>
<td align="center">100 * 1024</td>
<td align="center">The SO_SNDBUFF buffer the server prefers for socket connections.</td>
</tr>
<tr>
<td align="center">socket.receive.buffer.bytes</td>
<td align="center">100 * 1024</td>
<td align="center">The SO_RCVBUFF buffer the server prefers for socket connections.</td>
</tr>
<tr>
<td align="center">socket.request.max.bytes</td>
<td align="center">100 * 1024 * 1024</td>
<td align="center">服务器允许请求的最大值， 用来防止内存溢出，其值应该小于 Java heap size.</td>
</tr>
<tr>
<td align="center">num.partitions</td>
<td align="center">1</td>
<td align="center">默认partition数量，如果topic在创建时没有指定partition数量，默认使用此值，建议改为5</td>
</tr>
<tr>
<td align="center">log.segment.bytes</td>
<td align="center">1024 * 1024 * 1024</td>
<td align="center">Segment文件的大小，超过此值将会自动新建一个segment，此值可以被topic级别的参数覆盖。</td>
</tr>
<tr>
<td align="center">log.roll.{ms,hours}</td>
<td align="center">24 * 7 hours</td>
<td align="center">新建segment文件的时间，此值可以被topic级别的参数覆盖。</td>
</tr>
<tr>
<td align="center">log.retention.{ms,minutes,hours}</td>
<td align="center">7 days</td>
<td align="center">Kafka segment log的保存周期，保存周期超过此时间日志就会被删除。此参数可以被topic级别参数覆盖。数据量大时，建议减小此值</td>
</tr>
<tr>
<td align="center">log.retention.bytes</td>
<td align="center">-1</td>
<td align="center">每个partition的最大容量，若数据量超过此值，partition数据将会被删除。注意这个参数控制的是每个partition而不是topic。此参数可以被log级别参数覆盖。</td>
</tr>
<tr>
<td align="center">log.retention.check.interval.ms</td>
<td align="center">5 minutes</td>
<td align="center">删除策略的检查周期</td>
</tr>
<tr>
<td align="center">auto.create.topics.enable</td>
<td align="center">true</td>
<td align="center">自动创建topic参数，建议此值设置为false，严格控制topic管理，防止生产者错写topic。</td>
</tr>
<tr>
<td align="center">default.replication.factor</td>
<td align="center">1</td>
<td align="center">默认副本数量，建议改为2</td>
</tr>
<tr>
<td align="center">replica.lag.time.max.ms</td>
<td align="center">10000</td>
<td align="center">在此窗口时间内没有收到follower的fetch请求，leader会将其从ISR(in-sync replicas)中移除</td>
</tr>
<tr>
<td align="center">replica.lag.max.messages</td>
<td align="center">4000</td>
<td align="center">如果replica节点落后leader节点此值大小的消息数量，leader节点就会将其从ISR中移除。</td>
</tr>
<tr>
<td align="center">replica.socket.timeout.ms</td>
<td align="center">30 * 1000</td>
<td align="center">replica向leader发送请求的超时时间。</td>
</tr>
<tr>
<td align="center">replica.socket.receive.buffer.bytes</td>
<td align="center">64 * 1024</td>
<td align="center">The socket receive buffer for network requests to the leader for replicating data.</td>
</tr>
<tr>
<td align="center">replica.fetch.max.bytes</td>
<td align="center">1024 * 1024</td>
<td align="center">The number of byes of messages to attempt to fetch for each partition in the fetch requests the replicas send to the leader.</td>
</tr>
<tr>
<td align="center">replica.fetch.wait.max.ms</td>
<td align="center">500</td>
<td align="center">The maximum amount of time to wait time for data to arrive on the leader in the fetch requests sent by the replicas to the leader.</td>
</tr>
<tr>
<td align="center">num.replica.fetchers</td>
<td align="center">1</td>
<td align="center">Number of threads used to replicate messages from leaders. Increasing this value can increase the degree of I/O parallelism in the follower broker.</td>
</tr>
<tr>
<td align="center">fetch.purgatory.purge.interval.requests</td>
<td align="center">1000</td>
<td align="center">The purge interval (in number of requests) of the fetch request purgatory.</td>
</tr>
<tr>
<td align="center">zookeeper.session.timeout.ms</td>
<td align="center">6000</td>
<td align="center">ZooKeeper session 超时时间。如果在此时间内server没有向zookeeper发送心跳，zookeeper就会认为此节点已挂掉。 此值太低导致节点容易被标记死亡；若太高，.会导致太迟发现节点死亡</td>
</tr>
<tr>
<td align="center">zookeeper.connection.timeout.ms</td>
<td align="center">6000</td>
<td align="center">客户端连接zookeeper的超时时间。</td>
</tr>
<tr>
<td align="center">zookeeper.sync.time.ms</td>
<td align="center">2000</td>
<td align="center">H ZK follower落后 ZK leader的时间</td>
</tr>
<tr>
<td align="center">controlled.shutdown.enable</td>
<td align="center">true</td>
<td align="center">允许broker shutdown。如果启用，broker在关闭自己之前会把它上面的所有leaders转移到其它brokers上，建议启用，增加集群稳定性。</td>
</tr>
<tr>
<td align="center">auto.leader.rebalance.enable</td>
<td align="center">true</td>
<td align="center">If this is enabled the controller will automatically try to balance leadership for partitions among the brokers by periodically returning leadership to the “preferred” replica for each partition if it is available.</td>
</tr>
<tr>
<td align="center">leader.imbalance.per.broker.percentage</td>
<td align="center">10</td>
<td align="center">The percentage of leader imbalance allowed per broker. The controller will rebalance leadership if this ratio goes above the configured value per broker.</td>
</tr>
<tr>
<td align="center">leader.imbalance.check.interval.seconds</td>
<td align="center">300</td>
<td align="center">The frequency with which to check for leader imbalance.</td>
</tr>
<tr>
<td align="center">offset.metadata.max.bytes</td>
<td align="center">4096</td>
<td align="center">The maximum amount of metadata to allow clients to save with their offsets.</td>
</tr>
<tr>
<td align="center">connections.max.idle.ms</td>
<td align="center">600000</td>
<td align="center">Idle connections timeout: the server socket processor threads close the connections that idle more than this.</td>
</tr>
<tr>
<td align="center">num.recovery.threads.per.data.dir</td>
<td align="center">1</td>
<td align="center">The number of threads per data directory to be used for log recovery at startup and flushing at shutdown.</td>
</tr>
<tr>
<td align="center">unclean.leader.election.enable</td>
<td align="center">true</td>
<td align="center">Indicates whether to enable replicas not in the ISR set to be elected as leader as a last resort, even though doing so may result in data loss.</td>
</tr>
<tr>
<td align="center">delete.topic.enable</td>
<td align="center">false</td>
<td align="center">启用deletetopic参数，建议设置为true</td>
</tr>
<tr>
<td align="center">offsets.topic.num.partitions</td>
<td align="center">50</td>
<td align="center">The number of partitions for the offset commit topic. Since changing this after deployment is currently unsupported, we recommend using a higher setting for production (e.g., 100-200).</td>
</tr>
<tr>
<td align="center">offsets.topic.retention.minutes</td>
<td align="center">1440</td>
<td align="center">Offsets that are older than this age will be marked for deletion. The actual purge will occur when the log cleaner compacts the offsets topic.</td>
</tr>
<tr>
<td align="center">offsets.retention.check.interval.ms</td>
<td align="center">600000</td>
<td align="center">The frequency at which the offset manager checks for stale offsets.</td>
</tr>
<tr>
<td align="center">offsets.topic.replication.factor</td>
<td align="center">3</td>
<td align="center">The replication factor for the offset commit topic. A higher setting (e.g., three or four) is recommended in order to ensure higher availability. If the offsets topic is created when fewer brokers than the replication factor then the offsets topic will be created with fewer replicas.</td>
</tr>
<tr>
<td align="center">offsets.topic.segment.bytes</td>
<td align="center">104857600</td>
<td align="center">Segment size for the offsets topic. Since it uses a compacted topic, this should be kept relatively low in order to facilitate faster log compaction and loads.</td>
</tr>
<tr>
<td align="center">offsets.load.buffer.size</td>
<td align="center">5242880</td>
<td align="center">An offset load occurs when a broker becomes the offset manager for a set of consumer groups (i.e., when it becomes a leader for an offsets topic partition). This setting corresponds to the batch size (in bytes) to use when reading from the offsets segments when loading offsets into the offset manager’s cache.</td>
</tr>
<tr>
<td align="center">offsets.commit.required.acks</td>
<td align="center">-1</td>
<td align="center">The number of acknowledgements that are required before the offset commit can be accepted. This is similar to the producer’s acknowledgement setting. In general, the default should not be overridden.</td>
</tr>
<tr>
<td align="center">offsets.commit.timeout.ms</td>
<td align="center">5000</td>
<td align="center">The offset commit will be delayed until this timeout or the required number of replicas have received the offset commit. This is similar to the producer request timeout.</td>
</tr>
</tbody></table>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kafka/" rel="tag">Kafka</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Kafka命令行操作"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/02/02/Kafka%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/"
    >Kafka命令行操作</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/02/02/Kafka%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/" class="article-date">
  <time datetime="2019-02-02T07:50:00.000Z" itemprop="datePublished">2019-02-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Kafka/">Kafka</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="1-查看当前服务器中的所有topic"><a href="#1-查看当前服务器中的所有topic" class="headerlink" title="1.查看当前服务器中的所有topic"></a>1.查看当前服务器中的所有topic</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --zookeeper bigdata13:2181 --list</span><br></pre></td></tr></table></figure>
<h4 id="2-创建topic"><a href="#2-创建topic" class="headerlink" title="2.创建topic"></a>2.创建topic</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --zookeeper bigdata13:2181 --create --replication-factor 3 --partitions 1 --topic first</span><br></pre></td></tr></table></figure>
<p>选项说明：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--topic 定义topic名</span><br><span class="line"></span><br><span class="line">--replication-factor  定义副本数</span><br><span class="line"></span><br><span class="line">--partitions  定义分区数</span><br></pre></td></tr></table></figure>
<h4 id="3-删除topic"><a href="#3-删除topic" class="headerlink" title="3.删除topic"></a>3.删除topic</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --zookeeper bigdata11:2181 --delete --topic first</span><br></pre></td></tr></table></figure>
<p>需要server.properties中设置delete.topic.enable=true否则只是标记删除或者直接重启。</p>
<h4 id="4-发送消息"><a href="#4-发送消息" class="headerlink" title="4.发送消息"></a>4.发送消息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-producer.sh --broker-list bigdata11:9092 --topic first</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">hello world</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">itstar  itstar</span></span><br></pre></td></tr></table></figure>
<h4 id="5-消费消息"><a href="#5-消费消息" class="headerlink" title="5.消费消息"></a>5.消费消息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --zookeeper bigdata11:2181 --from-beginning --topic first</span><br></pre></td></tr></table></figure>
<p>–from-beginning：会把first主题中以往所有的数据都读取出来。根据业务场景选择是否增加该配置。</p>
<h4 id="6-查看某个Topic的详情"><a href="#6-查看某个Topic的详情" class="headerlink" title="6.查看某个Topic的详情"></a>6.查看某个Topic的详情</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --zookeeper bigdata11:2181 --describe --topic first </span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kafka/" rel="tag">Kafka</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Kafka集群安装部署"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/02/02/Kafka%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/"
    >Kafka集群安装部署</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/02/02/Kafka%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/" class="article-date">
  <time datetime="2019-02-02T06:50:00.000Z" itemprop="datePublished">2019-02-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Kafka/">Kafka</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="一-环境准备"><a href="#一-环境准备" class="headerlink" title="一. 环境准备"></a>一. 环境准备</h3><h4 id="1-集群规划"><a href="#1-集群规划" class="headerlink" title="1.集群规划"></a>1.集群规划</h4><table>
<thead>
<tr>
<th align="center">hadoop2</th>
<th align="center">hadoop3</th>
<th align="center">hadoop4</th>
</tr>
</thead>
<tbody><tr>
<td align="center">zk</td>
<td align="center">zk</td>
<td align="center">zk</td>
</tr>
<tr>
<td align="center">kafka</td>
<td align="center">kafka</td>
<td align="center">kafka</td>
</tr>
</tbody></table>
<h4 id="2-jar包下载"><a href="#2-jar包下载" class="headerlink" title="2.jar包下载"></a>2.jar包下载</h4><p><a target="_blank" rel="noopener" href="http://kafka.apache.org/downloads.html">http://kafka.apache.org/downloads.html</a></p>
<h4 id="3-虚拟机准备"><a href="#3-虚拟机准备" class="headerlink" title="3.虚拟机准备"></a>3.虚拟机准备</h4><p>(1).准备3台虚拟机</p>
<p>(2).配置ip地址</p>
<p>(3).配置主机名称</p>
<p>(4).3台主机分别关闭防火墙</p>
<h4 id="4-安装jdk"><a href="#4-安装jdk" class="headerlink" title="4.安装jdk"></a>4.安装jdk</h4><h4 id="5-安装Zookeeper"><a href="#5-安装Zookeeper" class="headerlink" title="5.安装Zookeeper"></a>5.安装Zookeeper</h4><p>在hadoop2、hadoop3和hadoop4三个节点上部署Zookeeper<br>见之前的文章</p>
<h3 id="二-Kafka集群部署"><a href="#二-Kafka集群部署" class="headerlink" title="二. Kafka集群部署"></a>二. Kafka集群部署</h3><h4 id="1-解压安装包"><a href="#1-解压安装包" class="headerlink" title="1.解压安装包"></a>1.解压安装包</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf kafka_2.11-0.11.0.2.tgz -C /opt/module/</span><br></pre></td></tr></table></figure>
<h4 id="2-修改解压后的文件名称"><a href="#2-修改解压后的文件名称" class="headerlink" title="2.修改解压后的文件名称"></a>2.修改解压后的文件名称</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv kafka_2.11-0.11.0.2/ kafka-2.11</span><br></pre></td></tr></table></figure>
<h4 id="3-在-opt-module-kafka目录下创建logs文件夹"><a href="#3-在-opt-module-kafka目录下创建logs文件夹" class="headerlink" title="3.在/opt/module/kafka目录下创建logs文件夹"></a>3.在/opt/module/kafka目录下创建logs文件夹</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/module/kafka-2.11</span><br><span class="line"></span><br><span class="line">mkdir logs</span><br></pre></td></tr></table></figure>
<h4 id="4-修改配置文件"><a href="#4-修改配置文件" class="headerlink" title="4.修改配置文件"></a>4.修改配置文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd config/</span><br><span class="line"></span><br><span class="line">vi server.properties</span><br></pre></td></tr></table></figure>
<p>输入以下内容：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#broker的全局唯一编号，不能重复</span><br><span class="line"></span><br><span class="line">broker.id=0</span><br><span class="line"></span><br><span class="line">#是否允许删除topic</span><br><span class="line"></span><br><span class="line">delete.topic.enable=true</span><br><span class="line"></span><br><span class="line">#处理网络请求的线程数量</span><br><span class="line"></span><br><span class="line">num.network.threads=3</span><br><span class="line"></span><br><span class="line">#用来处理磁盘IO的线程数量</span><br><span class="line"></span><br><span class="line">num.io.threads=8</span><br><span class="line"></span><br><span class="line">#发送套接字的缓冲区大小</span><br><span class="line"></span><br><span class="line">socket.send.buffer.bytes=102400</span><br><span class="line"></span><br><span class="line">#接收套接字的缓冲区大小</span><br><span class="line"></span><br><span class="line">socket.receive.buffer.bytes=102400</span><br><span class="line"></span><br><span class="line">#请求套接字的最大缓冲区大小</span><br><span class="line"></span><br><span class="line">socket.request.max.bytes=104857600</span><br><span class="line"></span><br><span class="line">#kafka运行日志存放的路径</span><br><span class="line"></span><br><span class="line">log.dirs=/opt/module/kafka-2.11/logs</span><br><span class="line"></span><br><span class="line">#topic在当前broker上的分区个数</span><br><span class="line"></span><br><span class="line">num.partitions=1</span><br><span class="line"></span><br><span class="line">#用来恢复和清理data下数据的线程数量</span><br><span class="line"></span><br><span class="line">num.recovery.threads.per.data.dir=1</span><br><span class="line"></span><br><span class="line">#segment文件保留的最长时间，超时将被删除</span><br><span class="line"></span><br><span class="line">log.retention.hours=168</span><br><span class="line"></span><br><span class="line">#配置连接Zookeeper集群地址</span><br><span class="line"></span><br><span class="line">zookeeper.connect=hadoop2:2181,hadoop3:2181,hadoop4:2181</span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LWQwODFiZWIzOWU0NmNjYWYucG5n?x-oss-process=image/format,png" alt="1"><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LTU0MDNmYjQ3YTkyMzI2ZWUucG5n?x-oss-process=image/format,png" alt="2"><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LTY2OTRmY2NhNjcwOWQ2OTgucG5n?x-oss-process=image/format,png" alt="3"></p>
<h4 id="5-配置环境变量"><a href="#5-配置环境变量" class="headerlink" title="5.配置环境变量"></a>5.配置环境变量</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br></pre></td></tr></table></figure>

<p>增加内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">KAFKA_HOME</span></span><br><span class="line">export KAFKA_HOME=/opt/module/kafka-2.11</span><br><span class="line"></span><br><span class="line">export PATH=$PATH:$KAFKA_HOME/bin</span><br></pre></td></tr></table></figure>
<p>使环境变量生效：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>
<h4 id="6-分发安装包"><a href="#6-分发安装包" class="headerlink" title="6.分发安装包"></a>6.分发安装包</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/module</span><br><span class="line"></span><br><span class="line">scp -r /kafka root@hadoop3:/opt/module/</span><br><span class="line">scp -r /kafka root@hadoop4:/opt/module/</span><br></pre></td></tr></table></figure>
<h4 id="7-分别在hadoop3和hadoop4上修改配置文件"><a href="#7-分别在hadoop3和hadoop4上修改配置文件" class="headerlink" title="7.分别在hadoop3和hadoop4上修改配置文件"></a>7.分别在hadoop3和hadoop4上修改配置文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /opt/module/kafka-2.11/config/server.properties</span><br></pre></td></tr></table></figure>
<p>将broker.id改了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//bigdata12</span><br><span class="line">broker.id=1</span><br><span class="line"></span><br><span class="line">//bigdata13</span><br><span class="line">broker.id=2</span><br></pre></td></tr></table></figure>
<p>注：broker.id不得重复</p>
<h4 id="8-启动集群"><a href="#8-启动集群" class="headerlink" title="8.启动集群"></a>8.启动集群</h4><p>依次在hadoop2、hadoop3、hadoop4节点上启动kafka(加上&amp; ,是在后台启动)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//hadoop2</span><br><span class="line">bin/kafka-server-start.sh config/server.properties &amp;</span><br><span class="line"></span><br><span class="line">//hadoop3</span><br><span class="line">bin/kafka-server-start.sh config/server.properties &amp;</span><br><span class="line"></span><br><span class="line">//hadoop4</span><br><span class="line">bin/kafka-server-start.sh config/server.properties &amp;</span><br></pre></td></tr></table></figure>
<h4 id="9-关闭集群"><a href="#9-关闭集群" class="headerlink" title="9.关闭集群"></a>9.关闭集群</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//hadoop2</span><br><span class="line">bin/kafka-server-stop.sh stop</span><br><span class="line"></span><br><span class="line">//hadoop3</span><br><span class="line">bin/kafka-server-stop.sh stop</span><br><span class="line"></span><br><span class="line">//hadoop4</span><br><span class="line">bin/kafka-server-stop.sh stop</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kafka/" rel="tag">Kafka</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/" rel="tag">安装部署</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Kafka概述"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/02/01/Kafka%E6%A6%82%E8%BF%B0/"
    >Kafka概述</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/02/01/Kafka%E6%A6%82%E8%BF%B0/" class="article-date">
  <time datetime="2019-02-01T06:50:00.000Z" itemprop="datePublished">2019-02-01</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Kafka/">Kafka</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="一-Kafka是什么"><a href="#一-Kafka是什么" class="headerlink" title="一.Kafka是什么"></a>一.Kafka是什么</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Kafka是最初由Linkedin公司开发，是一个分布式、支持分区的(partition)、多副本的(replica)，基于zookeeper协调的分布式消息系统，它的最大的特性就是可以实时的处理大量数据以满足各种需求场景：比如基于hadoop的批处理系统、低延迟的实时系统、storm/Spark流式处理引擎，web/nginx日志、访问日志，消息服务等等，用scala语言编写，Linkedin于2010年贡献给了Apache基金会并成为顶级开源 项目。</p>
<h3 id="二-架构模型"><a href="#二-架构模型" class="headerlink" title="二. 架构模型"></a>二. 架构模型</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LTJiZTkxMDk3MWY0ZWEzZGEucG5n?x-oss-process=image/format,png" alt="Kafka架构"></p>
<h3 id="三-JMS是什么"><a href="#三-JMS是什么" class="headerlink" title="三. JMS是什么"></a>三. JMS是什么</h3><h4 id="1-是什么："><a href="#1-是什么：" class="headerlink" title="1.是什么："></a>1.是什么：</h4><p>JMS(Java Message Service)是Java提供的一套技术规范</p>
<h4 id="2-作用："><a href="#2-作用：" class="headerlink" title="2.作用："></a>2.作用：</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;用来异构系统 集成通信，缓解系统瓶颈，提高系统的伸缩性增强系统用户体验，使得系统模块化和组件化变得可行并更加灵活</p>
<h4 id="3-传输模型："><a href="#3-传输模型：" class="headerlink" title="3.传输模型："></a>3.传输模型：</h4><h5 id="1-点对点模式-一对一，消费者主动拉取数据，消息收到后消息清除"><a href="#1-点对点模式-一对一，消费者主动拉取数据，消息收到后消息清除" class="headerlink" title="(1)点对点模式(一对一，消费者主动拉取数据，消息收到后消息清除)"></a>(1)点对点模式(一对一，消费者主动拉取数据，消息收到后消息清除)</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;点对点模型通常是一个基于拉取或者轮询的消息传送模型，这种模型从队列中请求信息，而不是将消息推送到客户端。这个模型的特点是发送到队列的消息被一个且只有一个接收者接收处理，即使有多个消息监听者也是如此。</p>
<h5 id="2-发布-订阅模式-一对多，数据生产后，推送给所有订阅者"><a href="#2-发布-订阅模式-一对多，数据生产后，推送给所有订阅者" class="headerlink" title="(2)发布/订阅模式(一对多，数据生产后，推送给所有订阅者)"></a>(2)发布/订阅模式(一对多，数据生产后，推送给所有订阅者)</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;发布订阅模型则是一个基于推送的消息传送模型。发布订阅模型可以有多种不同的订阅者，临时订阅者只在主动监听主题时才接收消息，而持久订阅者则监听主题的所有消息，即使当前订阅者不可用，处于离线状态。</p>
<h3 id="四-Kafka的特性"><a href="#四-Kafka的特性" class="headerlink" title="四.Kafka的特性"></a>四.Kafka的特性</h3><h4 id="1-高吞吐量、低延迟："><a href="#1-高吞吐量、低延迟：" class="headerlink" title="1.高吞吐量、低延迟："></a>1.高吞吐量、低延迟：</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒，每个topic可以分多个partition, consumer group 对partition进行consume操作。</p>
<h4 id="2-可扩展性："><a href="#2-可扩展性：" class="headerlink" title="2.可扩展性："></a>2.可扩展性：</h4><p>kafka集群支持热扩展</p>
<h4 id="3-持久性、可靠性："><a href="#3-持久性、可靠性：" class="headerlink" title="3.持久性、可靠性："></a>3.持久性、可靠性：</h4><p>消息被持久化到本地磁盘，并且支持数据备份防止数据丢失</p>
<h4 id="4-容错性："><a href="#4-容错性：" class="headerlink" title="4.容错性："></a>4.容错性：</h4><p>允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）</p>
<h4 id="5-高并发："><a href="#5-高并发：" class="headerlink" title="5.高并发："></a>5.高并发：</h4><p>支持数千个客户端同时读写</p>
<h3 id="五-使用场景"><a href="#五-使用场景" class="headerlink" title="五. 使用场景"></a>五. 使用场景</h3><h4 id="1-日志收集："><a href="#1-日志收集：" class="headerlink" title="1.日志收集："></a>1.日志收集：</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。</p>
<h4 id="2-消息系统："><a href="#2-消息系统：" class="headerlink" title="2.消息系统："></a>2.消息系统：</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;解耦和生产者和消费者、缓存消息等。</p>
<h4 id="3-用户活动跟踪："><a href="#3-用户活动跟踪：" class="headerlink" title="3.用户活动跟踪："></a>3.用户活动跟踪：</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。</p>
<h4 id="4-运营指标："><a href="#4-运营指标：" class="headerlink" title="4.运营指标："></a>4.运营指标：</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。</p>
<h4 id="5-流式处理："><a href="#5-流式处理：" class="headerlink" title="5.流式处理："></a>5.流式处理：</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;比如spark streaming和storm</p>
<h4 id="6-事件源"><a href="#6-事件源" class="headerlink" title="6.事件源"></a>6.事件源</h4><h3 id="六-分布式模型"><a href="#六-分布式模型" class="headerlink" title="六.分布式模型"></a>六.分布式模型</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Kafka每个主题的多个分区日志分布式地存储在Kafka集群上，同时为了故障容错，每个分区都会以副本的方式复制到多个消息代理节点上。其中一个节点会作为主副本(Leader)，其他节点作为备份副本(Follower，也叫作从副本)。主副本会负责所有的客户端读写操作，备份副本仅仅从主副本同步数据。当主副本出现故障时，备份副本中的一个副本会被选择为新的主副本。因为每个分区的副本中只有主副本接受读写，所以每个服务器端都会作为某些分区的主副本，以及另外一些分区的备份副本，这样Kafka集群的所有服务端整体上对客户端是负载均衡的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Kafka的生产者和消费者相对于服务器端而言都是客户端。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Kafka生产者客户端发布消息到服务端的指定主题，会指定消息所属的分区。生产者发布消息时根据消息是否有键，采用不同的分区策略。消息没有键时，通过轮询方式进行客户端负载均衡；消息有键时，根据分区语义（例如hash）确保相同键的消息总是发送到同一分区。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Kafka的消费者通过订阅主题来消费消息，并且每个消费者都会设置一个消费组名称。因为生产者发布到主题的每一条消息都只会发送给消费者组的一个消费者。所以，如果要实现传统消息系统的“队列”模型，可以让每个消费者都拥有相同的消费组名称，这样消息就会负责均衡到所有的消费者；如果要实现“发布-订阅”模型，则每个消费者的消费者组名称都不相同，这样每条消息就会广播给所有的消费者。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;分区是消费者现场模型的最小并行单位。如下图（图1）所示，生产者发布消息到一台服务器的3个分区时，只有一个消费者消费所有的3个分区。在下图（图2）中，3个分区分布在3台服务器上，同时有3个消费者分别消费不同的分区。假设每个服务器的吞吐量时300MB，在下图（图1）中分摊到每个分区只有100MB，而在下图（图2）中，集群整体的吞吐量有900MB。可以看到，增加服务器节点会提升集群的性能，增加消费者数量会提升处理性能。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;同一个消费组下多个消费者互相协调消费工作，Kafka会将所有的分区平均地分配给所有的消费者实例，这样每个消费者都可以分配到数量均等的分区。Kafka的消费组管理协议会动态地维护消费组的成员列表，当一个新消费者加入消费者组，或者有消费者离开消费组，都会触发再平衡操作。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LWVmNDZmZDA5MTM3YWI5ZmEucG5n?x-oss-process=image/format,png"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Kafka的消费者消费消息时，只保证在一个分区内的消息的完全有序性，并不保证同一个主题汇中多个分区的消息顺序。而且，消费者读取一个分区消息的顺序和生产者写入到这个分区的顺序是一致的。比如，生产者写入“hello”和“Kafka”两条消息到分区P1，则消费者读取到的顺序也一定是“hello”和“Kafka”。如果业务上需要保证所有消息完全一致，只能通过设置一个分区完成，但这种做法的缺点是最多只能有一个消费者进行消费。一般来说，只需要保证每个分区的有序性，再对消息假设键来保证相同键的所有消息落入同一分区，就可以满足绝大多数的应用。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kafka/" rel="tag">Kafka</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-数据结构与算法(8)-排序"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/01/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(8)-%E6%8E%92%E5%BA%8F/"
    >数据结构与算法(8)-排序</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/01/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(8)-%E6%8E%92%E5%BA%8F/" class="article-date">
  <time datetime="2019-01-23T10:00:00.000Z" itemprop="datePublished">2019-01-23</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="一-排序的基本概念与分类"><a href="#一-排序的基本概念与分类" class="headerlink" title="一.排序的基本概念与分类"></a>一.排序的基本概念与分类</h3><h4 id="1-定义："><a href="#1-定义：" class="headerlink" title="1.定义："></a>1.定义：</h4><h5 id="1-排序："><a href="#1-排序：" class="headerlink" title="(1)排序："></a>(1)排序：</h5><p>假设含有n个记录的序列为{r<sub>1</sub>,r<sub>2</sub>,……,r<sub>n</sub>}，其相应的关键字分别为{k<sub>1</sub>,k<sub>2</sub>,……,k<sub>n</sub>}，需确定1,2,……,n的一种排列p<sub>1</sub>,p<sub>2</sub>,……,p<sub>n</sub>，使其相应的关键字满足k<sub>p1</sub>≤k<sub>p2</sub>≤……≤k<sub>pn</sub>(非递减或非递增)关系，即使得序列成为一个按关键字有序的序列{r<sub>p1</sub>,r<sub>p2</sub>,……,r<sub>pn</sub>}，这样的操作就称为排序<br><sub></sub></p>
<h4 id="2-排序的稳定性："><a href="#2-排序的稳定性：" class="headerlink" title="2.排序的稳定性："></a>2.排序的稳定性：</h4><p>(1)假设k<sub>i</sub>=k<sub>j</sub>(1≤i≤n,1≤j≤n,i≠j)，且在排序前的序列中r<sub>i</sub>领先于r<sub>j</sub>(即i&lt;j)。如果排序后r<sub>i</sub>仍领先于r<sub>j</sub>，则称所用的排序方法是稳定的；反之，若可能使得排序后的序列中r<sub>j</sub>领先r<sub>i</sub>，则称所用的排序方法是不稳定的</p>
<h4 id="3-内排序与外排序"><a href="#3-内排序与外排序" class="headerlink" title="3.内排序与外排序"></a>3.内排序与外排序</h4><p>(1)内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中</p>
<p>(2)外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行</p>
<p>(3)对于内排序来说，排序算法的性能主要是受3个方面影响：</p>
<ul>
<li>时间性能：高效率的内排序算法应该是具有尽可能少的关键字比较次数和尽可能少的记录移动次数 </li>
<li>辅助空间：评价排序算法的另一个主要标准是执行算法所需要的辅助存储空间。辅助存储空间是除了存放待排序所占用的存储空间之外，执行算法所需要的其他存储空间</li>
<li>算法的复杂性：这里指的是算法本身的复杂度，而不是指算法的时间复杂度</li>
</ul>
<p>(4)内排序分为：插入排序、交换排序、选择排序和归并排序</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LTcxZThlMjAyODE3MmJiZTcucG5n?x-oss-process=image/format,png" alt="排序"></p>
<h3 id="二-冒泡排序"><a href="#二-冒泡排序" class="headerlink" title="二.冒泡排序"></a>二.冒泡排序</h3><h4 id="1-冒泡排序的基本思想："><a href="#1-冒泡排序的基本思想：" class="headerlink" title="1.冒泡排序的基本思想："></a>1.冒泡排序的基本思想：</h4><p>冒泡排序（Bubble Sort）一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止</p>
<h4 id="2-冒泡排序算法："><a href="#2-冒泡排序算法：" class="headerlink" title="2.冒泡排序算法："></a>2.冒泡排序算法：</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LTk3YTgxNjAxN2VkNzFiMWMucG5n?x-oss-process=image/format,png" alt="冒泡排序图解1"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LTg5ODM3MDYwYjczMzAzZGYucG5n?x-oss-process=image/format,png" alt="冒泡排序图解2"></p>
<h4 id="3-冒泡排序代码实现："><a href="#3-冒泡排序代码实现：" class="headerlink" title="3.冒泡排序代码实现："></a>3.冒泡排序代码实现：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">#### 4.冒泡排序优化</span><br><span class="line"></span><br><span class="line">#### 5.冒泡排序复杂度：</span><br><span class="line">冒泡排序的时间复杂度为O(n2)。</span><br><span class="line"></span><br><span class="line">### 三.简单选择排序</span><br><span class="line">#### 1.简单选择排序算法：</span><br><span class="line">##### (1)定义：</span><br><span class="line">简单选择排序法(Simple Selection Sort)就是通过n-i次关键字间的比较，从n-i＋1个记录中选出关键字最小的记录，并和第i(1≤i≤n)个记录交换之</span><br><span class="line"></span><br><span class="line">##### (2)代码实现：</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#### 2.简单选择排序复杂度分析：</span><br><span class="line">(1)简单选择排序的“时间复杂度依然为O(n&lt;sup&gt;2&lt;/sup&gt;)</span><br><span class="line"></span><br><span class="line">(2)尽管与冒泡排序同为O(n2)，但简单选择排序的性能上还是要略优于冒泡排序</span><br><span class="line"></span><br><span class="line">### 四.直接插入排序</span><br><span class="line">#### 1.直接插入排序算法：</span><br><span class="line">##### (1)定义：</span><br><span class="line">直接插入排序（Straight Insertion Sort）的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表 </span><br><span class="line"></span><br><span class="line">##### (2)代码实现：</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 2.直接插入排序复杂度分析</span><br><span class="line">(1)直接插入排序法的时间复杂度为O(n&lt;sup&gt;2&lt;/sup&gt;)</span><br><span class="line"></span><br><span class="line">(2)同样的O(n2)时间复杂度，直接插入排序法比冒泡和简单选择排序的性能要好一些</span><br><span class="line"></span><br><span class="line">### 五.希尔排序</span><br><span class="line">#### 1.希尔排序原理：</span><br><span class="line">#### 2.希尔排序算法：</span><br><span class="line">#### 3.希尔排序复杂度分析：</span><br><span class="line"></span><br><span class="line">### 六.堆排序：</span><br><span class="line">#### 1.定义：</span><br><span class="line">##### (1)堆排序(HeapSort)，就是对简单选择排序进行的一种改进</span><br><span class="line"></span><br><span class="line">##### (2)堆是具有下列性质的完全二叉树：</span><br><span class="line"></span><br><span class="line">* 每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆(如图所示)；</span><br><span class="line">* 或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆</span><br><span class="line"></span><br><span class="line">![堆](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LTZlODM2ZGEzMGM1NjY4NDUucG5n?x-oss-process=image/format,png)</span><br><span class="line"></span><br><span class="line">#### 2.堆排序算法：</span><br><span class="line">##### (1)堆排序（Heap Sort）就是利用堆（假设利用大顶堆）进行排序的方法</span><br><span class="line"></span><br><span class="line">##### (2)基本思想：</span><br><span class="line">将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走(其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值)，然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次大值。如此反复执行，便能得到一个有序序列了</span><br><span class="line"></span><br><span class="line">##### (3)代码实现：</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#### 3.堆排序复杂度分析：</span><br><span class="line">##### (1)堆排序的时间复杂度为O(nlogn)</span><br><span class="line"></span><br><span class="line">### 七.归并排序：</span><br><span class="line">#### 1.归并排序算法：</span><br><span class="line">##### (1)归并排序（Merging Sort）就是利用归并的思想实现的排序方法</span><br><span class="line"></span><br><span class="line">##### (2)原理：</span><br><span class="line">它的原理是假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到|n/2|（|x|表示不小于x的最小整数）个长度为2或1的有序子序列；再两两归并，……，如此重复，直至得到一个长度为n的有序序列为止，这种排序方法称为2路归并排序 </span><br><span class="line"></span><br><span class="line">##### (3)代码实现：</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#### 2.归并排序复杂度分析：</span><br><span class="line">##### (1)归并排序的算法复杂度为O(nlogn)</span><br><span class="line"></span><br><span class="line">###### 3.非递归实现归并排序：</span><br><span class="line">##### (1)代码实现：</span><br><span class="line"></span><br><span class="line">##### (2)使用归并排序时，尽量考虑用非递归方法</span><br><span class="line"></span><br><span class="line">### 八.快速排序：</span><br><span class="line">#### 1.含义：</span><br><span class="line">(1)希尔排序相当于直接插入排序的升级，它们同属于插入排序类</span><br><span class="line">(2)堆排序相当于简单选择排序的升级，它们同属于选择排序类。</span><br><span class="line">(3)而快速排序其实就是冒泡排序的升级，它们都属于交换排序类</span><br><span class="line"></span><br><span class="line">#### 2.快速排序算法：</span><br><span class="line">##### (1)基本思想：</span><br><span class="line">通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的</span><br><span class="line"></span><br><span class="line">##### (2)代码实现：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>```</p>
<h4 id="3-快速排序复杂度分析："><a href="#3-快速排序复杂度分析：" class="headerlink" title="3.快速排序复杂度分析："></a>3.快速排序复杂度分析：</h4><h5 id="1-快速排序的算法复杂度为O-nlogn"><a href="#1-快速排序的算法复杂度为O-nlogn" class="headerlink" title="(1)快速排序的算法复杂度为O(nlogn)"></a>(1)快速排序的算法复杂度为O(nlogn)</h5><h4 id="4-快速排序的优化"><a href="#4-快速排序的优化" class="headerlink" title="4.快速排序的优化"></a>4.快速排序的优化</h4><p>(1)优化选取枢轴<br>(2)优化不必要的交换<br>(3)优化小数组时的排序方案<br>(4)优化递归操作：</p>
<h3 id="九-总结："><a href="#九-总结：" class="headerlink" title="九.总结："></a>九.总结：</h3><h4 id="1-将内排序分为：插入排序、交换排序、选择排序和归并排序四类"><a href="#1-将内排序分为：插入排序、交换排序、选择排序和归并排序四类" class="headerlink" title="1.将内排序分为：插入排序、交换排序、选择排序和归并排序四类"></a>1.将内排序分为：插入排序、交换排序、选择排序和归并排序四类</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LWNmMjExOTMyNTk4ZjZhNzkucG5n?x-oss-process=image/format,png" alt="排序分类"></p>
<h4 id="2-排序算法复杂度："><a href="#2-排序算法复杂度：" class="headerlink" title="2.排序算法复杂度："></a>2.排序算法复杂度：</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LWQ4NGQxMGFjNmM0YTU3MzkucG5n?x-oss-process=image/format,png" alt="排序复杂度"></p>
<h4 id="3-从算法的简单性来看，我们将7种算法分为两类："><a href="#3-从算法的简单性来看，我们将7种算法分为两类：" class="headerlink" title="3.从算法的简单性来看，我们将7种算法分为两类："></a>3.从算法的简单性来看，我们将7种算法分为两类：</h4><ul>
<li>简单算法：冒泡、简单选择、直接插入</li>
<li>改进算法：希尔、堆、归并、快速</li>
</ul>
<p>(1)从平均情况来看，显然最后3种改进算法要胜过希尔排序，并远远胜过前3种简单算法。</p>
<p>(2)从最好情况看，反而冒泡和直接插入排序要更胜一筹，也就是说，如果你的待排序序列总是基本有序，反而不应该考虑4种复杂的改进算法。</p>
<p>(3)从最坏情况看，堆排序与归并排序又强过快速排序以及其他简单排序</p>
<p>(4)从稳定性来看，归并排序独占鳌头，对于非常在乎排序稳定性的应用中，归并排序是个好算法
 </p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-数据结构与算法(7)-查找"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/01/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(7)-%E6%9F%A5%E6%89%BE/"
    >数据结构与算法(7)-查找</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/01/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(7)-%E6%9F%A5%E6%89%BE/" class="article-date">
  <time datetime="2019-01-23T09:00:00.000Z" itemprop="datePublished">2019-01-23</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="一-查找概论"><a href="#一-查找概论" class="headerlink" title="一.查找概论"></a>一.查找概论</h3><h4 id="1-概念："><a href="#1-概念：" class="headerlink" title="1.概念："></a>1.概念：</h4><h5 id="1-查找表-Search-Table"><a href="#1-查找表-Search-Table" class="headerlink" title="(1)查找表(Search Table)"></a>(1)查找表(Search Table)</h5><p>是由同一类型的数据元素(或记录)构成的集合</p>
<h5 id="2-关键字（Key）"><a href="#2-关键字（Key）" class="headerlink" title="(2)关键字（Key）"></a>(2)关键字（Key）</h5><p>是数据元素中某个数据项的值，又称为键值，用它可以标识一个数据元素。也可以标识一个记录的某个数据项（字段），称为关键码</p>
<h5 id="3-主关键字："><a href="#3-主关键字：" class="headerlink" title="(3)主关键字："></a>(3)主关键字：</h5><p>若此关键字可以唯一地标识一个记录，则称此关键字为主关键字（Primary Key）</p>
<h5 id="4-次关键字："><a href="#4-次关键字：" class="headerlink" title="(4)次关键字："></a>(4)次关键字：</h5><p>对于那些可以识别多个数据元素（或记录）的关键字，我们称为次关键字，次关键字也可以理解为是不以唯一标识一个数据元素（或记录）的关键字，它对应的数据项就是次关键码</p>
<h4 id="2-查找表按照操作方式来分有两大种：静态查找表和动态查找表"><a href="#2-查找表按照操作方式来分有两大种：静态查找表和动态查找表" class="headerlink" title="2.查找表按照操作方式来分有两大种：静态查找表和动态查找表"></a>2.查找表按照操作方式来分有两大种：静态查找表和动态查找表</h4><h5 id="1-静态查找表-Static-Search-Table-：只作查找操作的查找表。"><a href="#1-静态查找表-Static-Search-Table-：只作查找操作的查找表。" class="headerlink" title="(1)静态查找表(Static Search Table)：只作查找操作的查找表。"></a>(1)静态查找表(Static Search Table)：只作查找操作的查找表。</h5><p>它的主要操作有：</p>
<ul>
<li>查询某个“特定的”数据元素是否在查找表中</li>
<li>检索某个“特定的”数据元素和各种属性</li>
</ul>
<h5 id="2-动态查找表-Dynamic-Search-Table-："><a href="#2-动态查找表-Dynamic-Search-Table-：" class="headerlink" title="(2)动态查找表(Dynamic Search Table)："></a>(2)动态查找表(Dynamic Search Table)：</h5><p>在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素<br>动态查找表的操作就是两个：</p>
<ul>
<li>查找时插入数据元素</li>
<li>查找时删除数据元素</li>
</ul>
<h4 id="3-面向查找操作的数据结构称为查找结构"><a href="#3-面向查找操作的数据结构称为查找结构" class="headerlink" title="3.面向查找操作的数据结构称为查找结构"></a>3.面向查找操作的数据结构称为查找结构</h4><h3 id="二-顺序表查找"><a href="#二-顺序表查找" class="headerlink" title="二.顺序表查找"></a>二.顺序表查找</h3><h4 id="1-顺序查找-Sequential-Search-又叫线性查找，是最基本的查找技术"><a href="#1-顺序查找-Sequential-Search-又叫线性查找，是最基本的查找技术" class="headerlink" title="1.顺序查找(Sequential Search):又叫线性查找，是最基本的查找技术"></a>1.顺序查找(Sequential Search):又叫线性查找，是最基本的查找技术</h4><h4 id="2-顺序表查找算法："><a href="#2-顺序表查找算法：" class="headerlink" title="2.顺序表查找算法："></a>2.顺序表查找算法：</h4><h4 id="3-顺序表查找算法优化："><a href="#3-顺序表查找算法优化：" class="headerlink" title="3.顺序表查找算法优化："></a>3.顺序表查找算法优化：</h4><h3 id="三-有序表查找"><a href="#三-有序表查找" class="headerlink" title="三.有序表查找"></a>三.有序表查找</h3><h4 id="1-折半查找"><a href="#1-折半查找" class="headerlink" title="1.折半查找"></a>1.折半查找</h4><h5 id="1-折半查找-Binary-Search-技术，又称为二分查找。"><a href="#1-折半查找-Binary-Search-技术，又称为二分查找。" class="headerlink" title="(1)折半查找(Binary Search)技术，又称为二分查找。"></a>(1)折半查找(Binary Search)技术，又称为二分查找。</h5><p>它的前提是线性表中的记录必须是关键码有序（通常从小到大有序），线性表必须采用顺序存储。</p>
<h5 id="2-折半查找的基本思想是："><a href="#2-折半查找的基本思想是：" class="headerlink" title="(2)折半查找的基本思想是："></a>(2)折半查找的基本思想是：</h5><p>在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止</p>
<h5 id="3-折半算法的时间复杂度为O-logn"><a href="#3-折半算法的时间复杂度为O-logn" class="headerlink" title="(3)折半算法的时间复杂度为O(logn)"></a>(3)折半算法的时间复杂度为O(logn)</h5><h4 id="2-插值查找"><a href="#2-插值查找" class="headerlink" title="2.插值查找"></a>2.插值查找</h4><p>插值查找(Interpolation Search)是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式(key-a[low])/(a[high]-a[low])</p>
<h4 id="3-斐波那契查找"><a href="#3-斐波那契查找" class="headerlink" title="3.斐波那契查找"></a>3.斐波那契查找</h4><h5 id="1-斐波那契查找-Fibonacci-Search-，是利用黄金分割原理来实现的"><a href="#1-斐波那契查找-Fibonacci-Search-，是利用黄金分割原理来实现的" class="headerlink" title="(1)斐波那契查找(Fibonacci Search)，是利用黄金分割原理来实现的"></a>(1)斐波那契查找(Fibonacci Search)，是利用黄金分割原理来实现的</h5><h5 id="2-“斐波那契查找算法的核心在于："><a href="#2-“斐波那契查找算法的核心在于：" class="headerlink" title="(2)“斐波那契查找算法的核心在于："></a>(2)“斐波那契查找算法的核心在于：</h5><ul>
<li>当key=a[mid]时，查找就成功；</li>
<li>当key&lt;a[mid]时，新范围是第low个到第mid-1个，此时范围个数为F[k-1]-1个；</li>
<li>当key&gt;a[mid]时，新范围是第m+1个到第high个，此时范围个数为F[k-2]-1个</li>
</ul>
<h4 id="4-三种有序表查找的区别在于："><a href="#4-三种有序表查找的区别在于：" class="headerlink" title="4.三种有序表查找的区别在于："></a>4.三种有序表查找的区别在于：</h4><ul>
<li>折半查找是进行加法与除法运算(mid=(low＋high)/2)，</li>
<li>插值查找进行复杂的四则运算(mid=low＋(high-low)*(key-a[low])/(a[high]-a[low]))，</li>
<li>而斐波那契查找只是最简单加减法运算(mid=low＋F[k-1]-1)</li>
</ul>
<h3 id="四-线性索引查找"><a href="#四-线性索引查找" class="headerlink" title="四.线性索引查找"></a>四.线性索引查找</h3><h4 id="1-含义："><a href="#1-含义：" class="headerlink" title="1.含义："></a>1.含义：</h4><h5 id="1-索引是为了加快查找速度而设计的一种数据结构。"><a href="#1-索引是为了加快查找速度而设计的一种数据结构。" class="headerlink" title="(1)索引是为了加快查找速度而设计的一种数据结构。"></a>(1)索引是为了加快查找速度而设计的一种数据结构。</h5><p>索引就是把一个关键字与它对应的记录相关联的过程，一个索引由若干个索引项构成，每个索引项至少应包含关键字和其对应的记录在存储器中的位置等信息</p>
<h5 id="2-索引按照结构可以分为线性索引、树形索引和多级索引"><a href="#2-索引按照结构可以分为线性索引、树形索引和多级索引" class="headerlink" title="(2)索引按照结构可以分为线性索引、树形索引和多级索引"></a>(2)索引按照结构可以分为线性索引、树形索引和多级索引</h5><h5 id="3-所谓线性索引就是将索引项集合组织为线性结构，也称为索引表"><a href="#3-所谓线性索引就是将索引项集合组织为线性结构，也称为索引表" class="headerlink" title="(3)所谓线性索引就是将索引项集合组织为线性结构，也称为索引表"></a>(3)所谓线性索引就是将索引项集合组织为线性结构，也称为索引表</h5><h4 id="2-稠密索引"><a href="#2-稠密索引" class="headerlink" title="2.稠密索引"></a>2.稠密索引</h4><h5 id="1-稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项"><a href="#1-稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项" class="headerlink" title="(1)稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项"></a>(1)稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项</h5><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LWNkZDczYzYzNTM5MWZjYjcucG5n?x-oss-process=image/format,png" alt="稠密索引"></p>
<h5 id="2-索引项有序也就意味着，我们要查找关键字时，可以用到折半、插值、斐波那契等有序查找算法，大大提高了效率"><a href="#2-索引项有序也就意味着，我们要查找关键字时，可以用到折半、插值、斐波那契等有序查找算法，大大提高了效率" class="headerlink" title="(2)索引项有序也就意味着，我们要查找关键字时，可以用到折半、插值、斐波那契等有序查找算法，大大提高了效率"></a>(2)索引项有序也就意味着，我们要查找关键字时，可以用到折半、插值、斐波那契等有序查找算法，大大提高了效率</h5><h4 id="3-分块索引"><a href="#3-分块索引" class="headerlink" title="3.分块索引"></a>3.分块索引</h4><h5 id="1-分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件："><a href="#1-分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件：" class="headerlink" title="(1)分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件："></a>(1)分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件：</h5><ul>
<li>块内无序，即每一块内的记录不要求有序 </li>
<li>块间有序</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LTZmMGQ3MThiYjNiZmZkMWEucG5n?x-oss-process=image/format,png" alt="分块索引"></p>
<h5 id="2-定义的分块索引的索引项结构分三个数据项："><a href="#2-定义的分块索引的索引项结构分三个数据项：" class="headerlink" title="(2)定义的分块索引的索引项结构分三个数据项："></a>(2)定义的分块索引的索引项结构分三个数据项：</h5><ul>
<li>最大关键码，它存储每一块中的最大关键字，这样的好处就是可以使得在它之后的下一块中的最小关键字也能比这一块最大的关键字要大；</li>
<li>存储了块中的记录个数，以便于循环时使用；</li>
<li>用于指向块首数据元素的指针，便于开始对这一块中记录进行遍历</li>
</ul>
<h5 id="3-在分块索引表中查找，就是分两步进行："><a href="#3-在分块索引表中查找，就是分两步进行：" class="headerlink" title="(3)在分块索引表中查找，就是分两步进行："></a>(3)在分块索引表中查找，就是分两步进行：</h5><ul>
<li>一是在分块索引表中查找要查关键字所在的块</li>
<li>二是根据块首指针找到相应的块，并在块中顺序查找关键码</li>
</ul>
<h4 id="4-倒排索引"><a href="#4-倒排索引" class="headerlink" title="4.倒排索引"></a>4.倒排索引</h4><h5 id="1-倒排索引的索引项通用结构是："><a href="#1-倒排索引的索引项通用结构是：" class="headerlink" title="(1)倒排索引的索引项通用结构是："></a>(1)倒排索引的索引项通用结构是：</h5><ul>
<li>次关键码，例如上面的“英文单词”；</li>
<li>记录号表，例如上面的“文章编号”。</li>
</ul>
<h5 id="2-其中记录号表存储具有相同次关键字的所有记录的记录号-这样的索引方法就是倒排索引"><a href="#2-其中记录号表存储具有相同次关键字的所有记录的记录号-这样的索引方法就是倒排索引" class="headerlink" title="(2)其中记录号表存储具有相同次关键字的所有记录的记录号,这样的索引方法就是倒排索引"></a>(2)其中记录号表存储具有相同次关键字的所有记录的记录号,这样的索引方法就是倒排索引</h5><h5 id="3-由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引"><a href="#3-由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引" class="headerlink" title="(3)由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引"></a>(3)由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引</h5><h3 id="五-二叉排序树"><a href="#五-二叉排序树" class="headerlink" title="五.二叉排序树"></a>五.二叉排序树</h3><h4 id="1-含义：-1"><a href="#1-含义：-1" class="headerlink" title="1.含义："></a>1.含义：</h4><h5 id="1-二叉排序树-Binary-Sort-Tree-，又称为二叉查找树。"><a href="#1-二叉排序树-Binary-Sort-Tree-，又称为二叉查找树。" class="headerlink" title="(1)二叉排序树(Binary Sort Tree)，又称为二叉查找树。"></a>(1)二叉排序树(Binary Sort Tree)，又称为二叉查找树。</h5><p>它或者是一棵空树，或者是具有下列性质的二叉树。</p>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值；</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉排序树</li>
</ul>
<h4 id="2-二叉排序树查找操作"><a href="#2-二叉排序树查找操作" class="headerlink" title="2.二叉排序树查找操作"></a>2.二叉排序树查找操作</h4><h5 id="1-二叉树结构"><a href="#1-二叉树结构" class="headerlink" title="(1)二叉树结构"></a>(1)二叉树结构</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二叉树的二叉链表结点结构定义 */</span></span><br><span class="line"><span class="comment">/* 结点结构 */</span></span><br><span class="line">typedef  struct BiTNode                 </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 结点数据 */</span></span><br><span class="line">    <span class="keyword">int</span> data;                           </span><br><span class="line">    <span class="comment">/* 左右孩子指针 */</span></span><br><span class="line">    struct BiTNode *lchild, *rchild;    </span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>
<h5 id="2-二叉树插入操作"><a href="#2-二叉树插入操作" class="headerlink" title="(2)二叉树插入操作"></a>(2)二叉树插入操作</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 递归查找二叉排序树T中是否存在key, */</span></span><br><span class="line"><span class="comment">/* 指针f指向T的双亲，其初始调用值为NULL */</span></span><br><span class="line"><span class="comment">/* 若查找成功，则指针p指向该数据元素结点，并</span></span><br><span class="line"><span class="comment">   返回TRUE */</span></span><br><span class="line"><span class="comment">/* 否则指针p指向查找路径上访问的最后一个结点</span></span><br><span class="line"><span class="comment">   并返回FALSE */</span></span><br><span class="line"><span class="function">Status <span class="title">SearchBST</span><span class="params">(BiTree T, <span class="keyword">int</span> key, BiTree f, BiTree *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 查找不成功 */</span></span><br><span class="line">    <span class="keyword">if</span> (!T)                                        </span><br><span class="line">    &#123;</span><br><span class="line">        *p = f;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 查找成功 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key == T-&gt;data)                       </span><br><span class="line">    &#123;</span><br><span class="line">       *p = T;</span><br><span class="line">       <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; T-&gt;data)</span><br><span class="line">        <span class="comment">/* 在左子树继续查找 */</span></span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;lchild, key, T, p);    </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">/* 在右子树继续查找 */</span></span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;rchild, key, T, p);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-二叉排序树插入操作"><a href="#3-二叉排序树插入操作" class="headerlink" title="3.二叉排序树插入操作"></a>3.二叉排序树插入操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 当二叉排序树T中不存在关键字等于key的数据元</span></span><br><span class="line"><span class="comment">   素时， */</span></span><br><span class="line"><span class="comment">/* 插入key并返回TRUE，否则返回FALSE */</span></span><br><span class="line"><span class="function">Status <span class="title">InsertBST</span><span class="params">(BiTree *T, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BiTree p, s;</span><br><span class="line">    <span class="comment">/* 查找不成功 */</span></span><br><span class="line">    <span class="keyword">if</span> (!SearchBST(*T, key, NULL, &amp;p))    </span><br><span class="line">    &#123;</span><br><span class="line">        s = (BiTree)malloc(sizeof(BiTNode));</span><br><span class="line">        s-&gt;data = key;</span><br><span class="line">        s-&gt;lchild = s-&gt;rchild = NULL;</span><br><span class="line">        <span class="keyword">if</span> (!p)</span><br><span class="line">            <span class="comment">/* 插入s为新的根结点 */</span></span><br><span class="line">            *T = s;                       </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; p-&gt;data)</span><br><span class="line">            <span class="comment">/* 插入s为左孩子 */</span></span><br><span class="line">            p-&gt;lchild = s;                </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">/* 插入s为右孩子 */</span></span><br><span class="line">            p-&gt;rchild = s;                </span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">/* 树中已有关键字相同的结点，不再插入 */</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;                     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-二叉排序树的删除操作："><a href="#4-二叉排序树的删除操作：" class="headerlink" title="4.二叉排序树的删除操作："></a>4.二叉排序树的删除操作：</h4><h5 id="1-删除结点三种情况："><a href="#1-删除结点三种情况：" class="headerlink" title="(1)删除结点三种情况："></a>(1)删除结点三种情况：</h5><ul>
<li>叶子结点；</li>
<li>仅有左或右子树的结点；</li>
<li>左右子树都有的结点，我们来看代码，下面这个算法是递归方式对二叉排序树T查找key，查找到时删除</li>
</ul>
<h4 id="5-二叉排序树总结："><a href="#5-二叉排序树总结：" class="headerlink" title="5.二叉排序树总结："></a>5.二叉排序树总结：</h4><h5 id="1-二叉排序树是以链接的方式存储，保持了链接存储结构在执行插入或删除操作时不用移动元素的优点，只要找到合适的插入和删除位置后，仅需修改链接指针即可"><a href="#1-二叉排序树是以链接的方式存储，保持了链接存储结构在执行插入或删除操作时不用移动元素的优点，只要找到合适的插入和删除位置后，仅需修改链接指针即可" class="headerlink" title="(1)二叉排序树是以链接的方式存储，保持了链接存储结构在执行插入或删除操作时不用移动元素的优点，只要找到合适的插入和删除位置后，仅需修改链接指针即可"></a>(1)二叉排序树是以链接的方式存储，保持了链接存储结构在执行插入或删除操作时不用移动元素的优点，只要找到合适的插入和删除位置后，仅需修改链接指针即可</h5><h5 id="2-一个集合按二叉排序树查找，最好是把它构建成一棵平衡的二叉排序树"><a href="#2-一个集合按二叉排序树查找，最好是把它构建成一棵平衡的二叉排序树" class="headerlink" title="(2)一个集合按二叉排序树查找，最好是把它构建成一棵平衡的二叉排序树"></a>(2)一个集合按二叉排序树查找，最好是把它构建成一棵平衡的二叉排序树</h5><h3 id="六-平衡二叉树"><a href="#六-平衡二叉树" class="headerlink" title="六.平衡二叉树"></a>六.平衡二叉树</h3><h4 id="1-含义：-2"><a href="#1-含义：-2" class="headerlink" title="1.含义："></a>1.含义：</h4><h5 id="1-平衡二叉树-Self-Balancing-Binary-SearchTree或Height-Balanced-Binary-Search-Tree"><a href="#1-平衡二叉树-Self-Balancing-Binary-SearchTree或Height-Balanced-Binary-Search-Tree" class="headerlink" title="(1)平衡二叉树(Self-Balancing Binary SearchTree或Height-Balanced Binary Search Tree)"></a>(1)平衡二叉树(Self-Balancing Binary SearchTree或Height-Balanced Binary Search Tree)</h5><p>是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1</p>
<h5 id="2-要么它是一棵空树，要么它的左子树和右子树都是平衡二叉树"><a href="#2-要么它是一棵空树，要么它的左子树和右子树都是平衡二叉树" class="headerlink" title="(2)要么它是一棵空树，要么它的左子树和右子树都是平衡二叉树"></a>(2)要么它是一棵空树，要么它的左子树和右子树都是平衡二叉树</h5><h5 id="3-距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，我们称为最小不平衡子树"><a href="#3-距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，我们称为最小不平衡子树" class="headerlink" title="(3)距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，我们称为最小不平衡子树"></a>(3)距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，我们称为最小不平衡子树</h5><h4 id="2-平衡二叉树的实现原理："><a href="#2-平衡二叉树的实现原理：" class="headerlink" title="2.平衡二叉树的实现原理："></a>2.平衡二叉树的实现原理：</h4><h5 id="1-当最小不平衡子树根结点的平衡因子BF是大于1时，就右旋，小于-1时就左旋"><a href="#1-当最小不平衡子树根结点的平衡因子BF是大于1时，就右旋，小于-1时就左旋" class="headerlink" title="(1)当最小不平衡子树根结点的平衡因子BF是大于1时，就右旋，小于-1时就左旋"></a>(1)当最小不平衡子树根结点的平衡因子BF是大于1时，就右旋，小于-1时就左旋</h5><h4 id="3-平衡二叉树实现算法："><a href="#3-平衡二叉树实现算法：" class="headerlink" title="3.平衡二叉树实现算法："></a>3.平衡二叉树实现算法：</h4><h5 id="1-二叉树结构定义"><a href="#1-二叉树结构定义" class="headerlink" title="(1)二叉树结构定义"></a>(1)二叉树结构定义</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二叉树的二叉链表结点结构定义 */</span></span><br><span class="line"><span class="comment">/* 结点结构 */</span></span><br><span class="line">typedef struct BiTNode                  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 结点数据 */</span></span><br><span class="line">    <span class="keyword">int</span> data;                           </span><br><span class="line">    <span class="comment">/* 结点的平衡因子 */</span></span><br><span class="line">    <span class="keyword">int</span> bf;                             </span><br><span class="line">    <span class="comment">/* 左右孩子指针 */</span></span><br><span class="line">    struct BiTNode *lchild, *rchild;    </span><br><span class="line">&#125; BiTNode, *BiTree; </span><br></pre></td></tr></table></figure>
<h5 id="2-右旋操作："><a href="#2-右旋操作：" class="headerlink" title="(2)右旋操作："></a>(2)右旋操作：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对以p为根的二叉排序树作右旋处理， */</span></span><br><span class="line"><span class="comment">/* 处理之后p指向新的树根结点，即旋转处理之前</span></span><br><span class="line"><span class="comment">   的左子树的根结点 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R_Rotate</span><span class="params">(BiTree *P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BiTree L;</span><br><span class="line">    <span class="comment">/* L指向P的左子树根结点 */</span></span><br><span class="line">    L = (*P)-&gt;lchild;            </span><br><span class="line">    <span class="comment">/* L的右子树挂接为P的左子树 */</span></span><br><span class="line">    (*P)-&gt;lchild = L-&gt;rchild;    </span><br><span class="line">    L-&gt;rchild = (*P);</span><br><span class="line">    <span class="comment">/* P指向新的根结点 */</span></span><br><span class="line">    *P = L;                      </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h5 id="3-左旋操作"><a href="#3-左旋操作" class="headerlink" title="(3)左旋操作"></a>(3)左旋操作</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对以P为根的二叉排序树作左旋处理， */</span></span><br><span class="line"><span class="comment">/* 处理之后P指向新的树根结点，即旋转处理之前</span></span><br><span class="line"><span class="comment">   的右子树的根结点0 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">L_Rotate</span><span class="params">(BiTree *P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BiTree R;</span><br><span class="line">    <span class="comment">/* R指向P的右子树根结点 */</span></span><br><span class="line">    R = (*P)-&gt;rchild;            </span><br><span class="line">    <span class="comment">/* R的左子树挂接为P的右子树 */</span></span><br><span class="line">    (*P)-&gt;rchild = R-&gt;lchild;    </span><br><span class="line">    R-&gt;lchild = (*P);</span><br><span class="line">    <span class="comment">/* P指向新的根结点 */</span></span><br><span class="line">    *P = R;                      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="七-多路查找树-B树"><a href="#七-多路查找树-B树" class="headerlink" title="七.多路查找树(B树)"></a>七.多路查找树(B树)</h3><h4 id="1-含义：-3"><a href="#1-含义：-3" class="headerlink" title="1.含义："></a>1.含义：</h4><h5 id="1-多路查找树-muitl-way-search-tree-，"><a href="#1-多路查找树-muitl-way-search-tree-，" class="headerlink" title="(1)多路查找树(muitl-way search tree)，"></a>(1)多路查找树(muitl-way search tree)，</h5><p>其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素。由于它是查找树，所有元素之间存在某种特定的排序关系。</p>
<h5 id="2-四种特殊形式：2-3树、2-3-4树、B树和B-树"><a href="#2-四种特殊形式：2-3树、2-3-4树、B树和B-树" class="headerlink" title="(2)四种特殊形式：2-3树、2-3-4树、B树和B+树"></a>(2)四种特殊形式：2-3树、2-3-4树、B树和B+树</h5><h4 id="2-2-3树"><a href="#2-2-3树" class="headerlink" title="2.2-3树"></a>2.2-3树</h4><h5 id="1-含义：-4"><a href="#1-含义：-4" class="headerlink" title="(1)含义："></a>(1)含义：</h5><p>2-3树是这样的一棵多路查找树：其中的每一个结点都具有两个孩子(我们称它为2结点)或三个孩子(我们称它为3结点)</p>
<h5 id="2-一个2结点包含一个元素和两个孩子-或没有孩子-，"><a href="#2-一个2结点包含一个元素和两个孩子-或没有孩子-，" class="headerlink" title="(2)一个2结点包含一个元素和两个孩子(或没有孩子)，"></a>(2)一个2结点包含一个元素和两个孩子(或没有孩子)，</h5><p>且与二叉排序树类似，左子树包含的元素小于该元素，右子树包含的元素大于该元素，这个2结点要么没有孩子，要有就有两个，不能只有一个孩子</p>
<h5 id="3-一个3结点包含一小一大两个元素和三个孩子-或没有孩子-，"><a href="#3-一个3结点包含一小一大两个元素和三个孩子-或没有孩子-，" class="headerlink" title="(3)一个3结点包含一小一大两个元素和三个孩子(或没有孩子)，"></a>(3)一个3结点包含一小一大两个元素和三个孩子(或没有孩子)，</h5><p>如果某个3结点有孩子的话，左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素</p>
<h5 id="4-2-3树的插入实现："><a href="#4-2-3树的插入实现：" class="headerlink" title="(4)2-3树的插入实现："></a>(4)2-3树的插入实现：</h5><p>对于2-3树的插入来说，与二叉排序树相同，插入操作一定是发生在叶子结点上。可与二叉排序树不同的是，2-3树插入一个元素的过程有可能会对该树的其余结构产生连锁反应</p>
<h5 id="5-2-3树插入分三种情况："><a href="#5-2-3树插入分三种情况：" class="headerlink" title="(5)2-3树插入分三种情况："></a>(5)2-3树插入分三种情况：</h5><ul>
<li>对于空树，插入一个2结点即可</li>
<li>插入结点到一个2结点的叶子上。应该说，由于其本身就只有一个元素，所以只需要将其升级为3结点即可</li>
<li>要往3结点中插入一个新元素。因为3结点本身已经是2-3树的结点最大容量(已经有两个元素)，因此就需要将其拆分，且将树中两元素或插入元素的三者中选择其一向上移动一层</li>
</ul>
<h5 id="6-2-3树的删除实现："><a href="#6-2-3树的删除实现：" class="headerlink" title="(6)2-3树的删除实现："></a>(6)2-3树的删除实现：</h5><ul>
<li>所删除元素位于一个3结点的叶子结点上， 只需要在该结点处删除该元素即可，不会影响到整棵树的其他结点结构</li>
<li>所删除的元素位于一个2结点上，即要删除的是一个只有一个元素的结点，分四种情形，情形一，结点的双亲也是2结点，且拥有一个3结点的右孩子。若要删除结点1，那么只需要左旋即可；情形二，结点的双亲是2结点，它的右孩子也是2结点；情形三，此结点的双亲是一个3结点；情形四，当前树是一个满二叉树的情况</li>
<li>所删除的元素位于非叶子的分支结点。此时通常是将树按中序遍历后得到此元素的前驱或后继元素，考虑让它们来补位即可</li>
</ul>
<h4 id="3-2-3-4树"><a href="#3-2-3-4树" class="headerlink" title="3.2-3-4树"></a>3.2-3-4树</h4><h5 id="1-含义：-5"><a href="#1-含义：-5" class="headerlink" title="(1)含义："></a>(1)含义：</h5><p>它其实就是2-3树的概念扩展，包括了4结点的使用。一个4结点包含小中大三个元素和四个孩子(或没有孩子)，一个4结点要么没有孩子，要么具有4个孩子。如果某个4结点有孩子的话，左子树包含小于最小元素的元素；第二子树包含大于最小元素，小于第二元素的元素；第三子树包含大于第二元素，小于最大元素的元素；右子树包含大于最大元素的元素</p>
<h4 id="4-B树"><a href="#4-B树" class="headerlink" title="4.B树"></a>4.B树</h4><h5 id="1-含义：-6"><a href="#1-含义：-6" class="headerlink" title="(1)含义："></a>(1)含义：</h5><p>结点最大的孩子数目称为B树的阶（order），因此，2-3树是3阶B树，2-3-4树是4阶B树。</p>
<h5 id="2-一个m阶的B树具有如下属性："><a href="#2-一个m阶的B树具有如下属性：" class="headerlink" title="(2)一个m阶的B树具有如下属性："></a>(2)一个m阶的B树具有如下属性：</h5><ul>
<li>如果根结点不是叶结点，则其至少有两棵子树。</li>
<li>每一个非根的分支结点都有k-1个元素和k个孩子，其中。每一个叶子结点n都有k-1个元素，</li>
<li>所有叶子结点都位于同一层次。</li>
<li>所有分支结点包含下列信息数据</li>
</ul>
<h5 id="3-在B树上查找的过程是一个顺指针查找结点和在结点中查找关键字的交叉过程"><a href="#3-在B树上查找的过程是一个顺指针查找结点和在结点中查找关键字的交叉过程" class="headerlink" title="(3)在B树上查找的过程是一个顺指针查找结点和在结点中查找关键字的交叉过程"></a>(3)在B树上查找的过程是一个顺指针查找结点和在结点中查找关键字的交叉过程</h5><h5 id="4-至于B树的插入和删除，方式是与2-3树和2-3-4树相类似的，只不过阶数可能会很大而已"><a href="#4-至于B树的插入和删除，方式是与2-3树和2-3-4树相类似的，只不过阶数可能会很大而已" class="headerlink" title="(4)至于B树的插入和删除，方式是与2-3树和2-3-4树相类似的，只不过阶数可能会很大而已"></a>(4)至于B树的插入和删除，方式是与2-3树和2-3-4树相类似的，只不过阶数可能会很大而已</h5><h4 id="5-B-树"><a href="#5-B-树" class="headerlink" title="5.B+树"></a>5.B+树</h4><h5 id="1-含义：-7"><a href="#1-含义：-7" class="headerlink" title="(1)含义："></a>(1)含义：</h5><p>B+树是应文件系统所需而出的一种B树的变形树</p>
<h5 id="2-在B树中，每一个元素在该树中只出现一次，有可能在叶子结点上，也有可能在分支结点上。而在B-树中，出现在分支结点中的元素会被当作它们在该分支结点位置的中序后继者（叶子结点）中再次列出。另外，每一个叶子结点都会保存一个指向后一叶子结点的指针"><a href="#2-在B树中，每一个元素在该树中只出现一次，有可能在叶子结点上，也有可能在分支结点上。而在B-树中，出现在分支结点中的元素会被当作它们在该分支结点位置的中序后继者（叶子结点）中再次列出。另外，每一个叶子结点都会保存一个指向后一叶子结点的指针" class="headerlink" title="(2)在B树中，每一个元素在该树中只出现一次，有可能在叶子结点上，也有可能在分支结点上。而在B+树中，出现在分支结点中的元素会被当作它们在该分支结点位置的中序后继者（叶子结点）中再次列出。另外，每一个叶子结点都会保存一个指向后一叶子结点的指针"></a>(2)在B树中，每一个元素在该树中只出现一次，有可能在叶子结点上，也有可能在分支结点上。而在B+树中，出现在分支结点中的元素会被当作它们在该分支结点位置的中序后继者（叶子结点）中再次列出。另外，每一个叶子结点都会保存一个指向后一叶子结点的指针</h5><h5 id="3-一棵m阶的B-树和m阶的B树的差异在于："><a href="#3-一棵m阶的B-树和m阶的B树的差异在于：" class="headerlink" title="(3)一棵m阶的B+树和m阶的B树的差异在于："></a>(3)一棵m阶的B+树和m阶的B树的差异在于：</h5><ul>
<li>有n棵子树的结点中包含有n个关键字；</li>
<li>所有的叶子结点包含全部关键字的信息，及指向含这些关键字记录的指针，叶子结点本身依关键字的大小自小而大顺序链接；</li>
<li>所有分支结点可以看成是索引，结点中仅含有其子树中的最大(或最小)关键字</li>
</ul>
<h5 id="4-B-树的插入、删除过程也都与B树类似，只不过插入和删除的元素都是在叶子结点上进行而已"><a href="#4-B-树的插入、删除过程也都与B树类似，只不过插入和删除的元素都是在叶子结点上进行而已" class="headerlink" title="(4)B+树的插入、删除过程也都与B树类似，只不过插入和删除的元素都是在叶子结点上进行而已"></a>(4)B+树的插入、删除过程也都与B树类似，只不过插入和删除的元素都是在叶子结点上进行而已</h5><h3 id="八-散列表查找-哈希表-概述"><a href="#八-散列表查找-哈希表-概述" class="headerlink" title="八.散列表查找(哈希表)概述"></a>八.散列表查找(哈希表)概述</h3><h4 id="1-散列表查找定义："><a href="#1-散列表查找定义：" class="headerlink" title="1.散列表查找定义："></a>1.散列表查找定义：</h4><p>(1)散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f </p>
<p>(2)这种对应关系f称为散列函数，又称为哈希（Hash）函数</p>
<p>(3)按这个思想，采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表（Hash table）。那么关键字对应的记录存储位置我们称为散列地址</p>
<h4 id="2-散列表查找步骤："><a href="#2-散列表查找步骤：" class="headerlink" title="2.散列表查找步骤："></a>2.散列表查找步骤：</h4><p>(1)在存储时，通过散列函数计算记录的散列地址，并按此散列地址存储该记录</p>
<p>(2)当查找记录时，我们通过同样的散列函数计算记录的散列地址，按此散列地址访问该记录</p>
<h4 id="3-散列主要是面向查找的存储结构。"><a href="#3-散列主要是面向查找的存储结构。" class="headerlink" title="3.散列主要是面向查找的存储结构。"></a>3.散列主要是面向查找的存储结构。</h4><h3 id="九-散列函数的构造方法"><a href="#九-散列函数的构造方法" class="headerlink" title="九.散列函数的构造方法"></a>九.散列函数的构造方法</h3><h4 id="1-好的散列函数的两个原则："><a href="#1-好的散列函数的两个原则：" class="headerlink" title="1.好的散列函数的两个原则："></a>1.好的散列函数的两个原则：</h4><h5 id="1-计算简单"><a href="#1-计算简单" class="headerlink" title="(1)计算简单"></a>(1)计算简单</h5><h5 id="2-散列地址分布均匀"><a href="#2-散列地址分布均匀" class="headerlink" title="(2)散列地址分布均匀"></a>(2)散列地址分布均匀</h5><h4 id="2-直接定址法"><a href="#2-直接定址法" class="headerlink" title="2.直接定址法"></a>2.直接定址法</h4><h4 id="3-数字分析法："><a href="#3-数字分析法：" class="headerlink" title="3.数字分析法："></a>3.数字分析法：</h4><p>(1)抽取方法是使用关键字的一部分来计算散列存储位置的方法，这在散列函数中是常常用到的手段 </p>
<p>(2)数字分析法通常适合处理关键字位数比较大的情况，如果事先知道关键字的分布且关键字的若干位分布较均匀，就可以考虑用这个方法</p>
<h4 id="4-平方取中法"><a href="#4-平方取中法" class="headerlink" title="4.平方取中法"></a>4.平方取中法</h4><h4 id="5-折叠法："><a href="#5-折叠法：" class="headerlink" title="5.折叠法："></a>5.折叠法：</h4><h5 id="1-含义：-8"><a href="#1-含义：-8" class="headerlink" title="(1)含义："></a>(1)含义：</h5><p>折叠法是将关键字从左到右分割成位数相等的几部分（注意最后一部分位数不够时可以短些），然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址</p>
<h4 id="6-除留余数法："><a href="#6-除留余数法：" class="headerlink" title="6.除留余数法："></a>6.除留余数法：</h4><p>此方法为最常用的构造散列函数方法。对于散列表长为m的散列函数公式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(key)=key mod p(p≤m)</span><br></pre></td></tr></table></figure>
<p>mod是取模（求余数）的意思 </p>
<h4 id="6-随机数法："><a href="#6-随机数法：" class="headerlink" title="6.随机数法："></a>6.随机数法：</h4><h4 id="7-采用不同散列函数的因素："><a href="#7-采用不同散列函数的因素：" class="headerlink" title="7.采用不同散列函数的因素："></a>7.采用不同散列函数的因素：</h4><p>(1).计算散列地址所需的时间<br>(2).关键字的长度<br>(3).散列表的大小<br>(4).关键字的分布情况<br>(5).记录查找的频率</p>
<h3 id="十-处理散列冲突的方法："><a href="#十-处理散列冲突的方法：" class="headerlink" title="十.处理散列冲突的方法："></a>十.处理散列冲突的方法：</h3><h4 id="1-开放定址法"><a href="#1-开放定址法" class="headerlink" title="1.开放定址法"></a>1.开放定址法</h4><h4 id="2-再散列函数法"><a href="#2-再散列函数法" class="headerlink" title="2.再散列函数法"></a>2.再散列函数法</h4><h4 id="3-链地址法"><a href="#3-链地址法" class="headerlink" title="3.链地址法"></a>3.链地址法</h4><h4 id="4-公共溢出区法"><a href="#4-公共溢出区法" class="headerlink" title="4.公共溢出区法"></a>4.公共溢出区法</h4><h3 id="十一-散列表查找实现"><a href="#十一-散列表查找实现" class="headerlink" title="十一.散列表查找实现"></a>十一.散列表查找实现</h3><h4 id="1-散列表查找算法实现"><a href="#1-散列表查找算法实现" class="headerlink" title="1.散列表查找算法实现"></a>1.散列表查找算法实现</h4><h4 id="2-散列表查找性能分析"><a href="#2-散列表查找性能分析" class="headerlink" title="2.散列表查找性能分析"></a>2.散列表查找性能分析</h4><p>(1)如果没有冲突，散列查找是我们本章介绍的所有查找中效率最高的，因为它的时间复杂度为O(1)<br>(2)散列查找的平均查找长度取决于的因素</p>
<ul>
<li>散列函数是否均匀</li>
<li>处理冲突的方法</li>
<li>散列表的装填因子，所谓的装填因子α=填入表中的记录个数/散列表长度。α标志着散列表的装满的程度。当填入表中的记录越多，α就越大，产生冲突的可能性就越大</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-数据结构与算法(6)-图"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/01/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(6)-%E5%9B%BE/"
    >数据结构与算法(6)-图</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/01/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(6)-%E5%9B%BE/" class="article-date">
  <time datetime="2019-01-23T08:00:00.000Z" itemprop="datePublished">2019-01-23</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="一-图的定义"><a href="#一-图的定义" class="headerlink" title="一.图的定义"></a>一.图的定义</h3><h4 id="1-定义："><a href="#1-定义：" class="headerlink" title="1.定义："></a>1.定义：</h4><p>(1)图(Graph)是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合</p>
<p>(2)图按照有无方向分为无向图和有向图。无向图由顶点和边构成，有向图由顶点和弧构成。弧有弧尾和弧头之分</p>
<p>(3)图按照边或弧的多少分稀疏图和稠密图。如果任意两个顶点之间都存在边叫完全图，有向的叫有向完全图。若无重复的边或顶点到自身的边则叫简单图</p>
<p>(4)图中顶点之间有邻接点、依附的概念。无向图顶点的边数叫做度，有向图顶点分为入度和出度 </p>
<p>(5)图上的边或弧上带权则称为网</p>
<p>(6)图中顶点间存在路径，两顶点存在路径则说明是连通的，如果路径最终回到起始点则称为环，当中不重复叫简单路径。若任意两顶点都是连通的，则图就是连通图，有向则称强连通图。图中有子图，若子图极大连通则就是连通分量，有向的则称强连通分量</p>
<p>(7)无向图中连通且n个顶点n-1条边叫生成树。有向图中一顶点入度为0其余顶点入度为1的叫有向树。一个有向图由若干棵有向树构成生成森林</p>
<h3 id="二-图的抽象数据类型"><a href="#二-图的抽象数据类型" class="headerlink" title="二.图的抽象数据类型"></a>二.图的抽象数据类型</h3><h3 id="三-图的存储结构"><a href="#三-图的存储结构" class="headerlink" title="三.图的存储结构"></a>三.图的存储结构</h3><h4 id="1-邻接矩阵"><a href="#1-邻接矩阵" class="headerlink" title="1.邻接矩阵"></a>1.邻接矩阵</h4><p>图的邻接矩阵（Adjacency Matrix）存储方式是用两个数组来表示图<br>(1)设图G有n个顶点，则邻接矩阵是一个n×n的方阵，定义为：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LTA3OWIyOGRlMjBkM2UzMGQucG5n?x-oss-process=image/format,png"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LWQ5NTg4MTUwZGI3MTU5ODAucG5n?x-oss-process=image/format,png" alt="无向图"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LTZlNDk4YzFiNjkxZmZmYTgucG5n?x-oss-process=image/format,png" alt="有向图"></p>
<h4 id="2-邻接表"><a href="#2-邻接表" class="headerlink" title="2.邻接表"></a>2.邻接表</h4><h5 id="1-定义：-1"><a href="#1-定义：-1" class="headerlink" title="(1)定义："></a>(1)定义：</h5><p>图中顶点用一个一维数组存储，当然，顶点也可以用单链表来存储，不过数组可以较容易地读取顶点信息，更加方便。另外，对于顶点数组中，每个数据元素还需要存储指向第一个邻接点的指针，以便于查找该顶点的边信息。</p>
<p>图中每个顶点vi的所有邻接点构成一个线性表，由于邻接点的个数不定，所以用单链表存储，无向图称为顶点vi的边表，有向图则称为顶点vi作为弧尾的出边表。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LTM3NzE4MjBkZGM5NTY3NGQucG5n?x-oss-process=image/format,png" alt="无向图的邻接表结构"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LTg2MThkZGM0Njg4OTAxYjkucG5n?x-oss-process=image/format,png" alt="有向图的邻接表结构"></p>
<h4 id="3-十字链表"><a href="#3-十字链表" class="headerlink" title="3.十字链表"></a>3.十字链表</h4><p>(1)十字链表的好处就是因为把邻接表和逆邻接表整合在了一起，这样既容易找到以vi为尾的弧，也容易找到以vi为头的弧，因而容易求得顶点的出度和入度</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LTczZDQ2Y2Q4YTdjOGIxODkucG5n?x-oss-process=image/format,png" alt="十字链表"></p>
<h4 id="4-邻接多重表"><a href="#4-邻接多重表" class="headerlink" title="4.邻接多重表"></a>4.邻接多重表</h4><h4 id="5-边集数组"><a href="#5-边集数组" class="headerlink" title="5.边集数组"></a>5.边集数组</h4><h5 id="1-边集数组是由两个一维数组构成。"><a href="#1-边集数组是由两个一维数组构成。" class="headerlink" title="(1)边集数组是由两个一维数组构成。"></a>(1)边集数组是由两个一维数组构成。</h5><p>一个是存储顶点的信息；另一个是存储边的信息，这个边数组每个数据元素由一条边的起点下标（begin）、终点下标（end）和权（weight）组成</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LWNjNzJkYjhmZGY0N2NjNjkucG5n?x-oss-process=image/format,png" alt="边集数组"></p>
<h3 id="四-图的遍历"><a href="#四-图的遍历" class="headerlink" title="四.图的遍历"></a>四.图的遍历</h3><h4 id="1-深度优先遍历"><a href="#1-深度优先遍历" class="headerlink" title="1.深度优先遍历"></a>1.深度优先遍历</h4><h5 id="1-深度优先遍历-Depth-First-Search-，也有称为深度优先搜索，简称为DFS"><a href="#1-深度优先遍历-Depth-First-Search-，也有称为深度优先搜索，简称为DFS" class="headerlink" title="(1)深度优先遍历(Depth_First_Search)，也有称为深度优先搜索，简称为DFS"></a>(1)深度优先遍历(Depth_First_Search)，也有称为深度优先搜索，简称为DFS</h5><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LTU5YjJkYmVhMDk3NzE4NzgucG5n?x-oss-process=image/format,png" alt="深度优先遍历"></p>
<h4 id="2-广度优先遍历"><a href="#2-广度优先遍历" class="headerlink" title="2.广度优先遍历"></a>2.广度优先遍历</h4><h5 id="1-广度优先遍历-Breadth-First-Search-，又称为广度优先搜索，简称BFS"><a href="#1-广度优先遍历-Breadth-First-Search-，又称为广度优先搜索，简称BFS" class="headerlink" title="(1)广度优先遍历(Breadth_First_Search)，又称为广度优先搜索，简称BFS"></a>(1)广度优先遍历(Breadth_First_Search)，又称为广度优先搜索，简称BFS</h5><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LThkZDY2MDBlN2Y1YzhlMDMucG5n?x-oss-process=image/format,png" alt="广度优先遍历"></p>
<h3 id="五-最小生成树"><a href="#五-最小生成树" class="headerlink" title="五.最小生成树"></a>五.最小生成树</h3><h4 id="1-普里姆-prim-算法"><a href="#1-普里姆-prim-算法" class="headerlink" title="1.普里姆(prim)算法"></a>1.普里姆(prim)算法</h4><h4 id="2-克鲁斯卡尔-Kruskal-算法"><a href="#2-克鲁斯卡尔-Kruskal-算法" class="headerlink" title="2.克鲁斯卡尔(Kruskal)算法"></a>2.克鲁斯卡尔(Kruskal)算法</h4><h3 id="六-最短路径"><a href="#六-最短路径" class="headerlink" title="六.最短路径"></a>六.最短路径</h3><h4 id="1-迪杰斯特拉-Dijkstra-算法"><a href="#1-迪杰斯特拉-Dijkstra-算法" class="headerlink" title="1.迪杰斯特拉(Dijkstra)算法"></a>1.迪杰斯特拉(Dijkstra)算法</h4><h4 id="2-弗洛伊德（Floyd）算法"><a href="#2-弗洛伊德（Floyd）算法" class="headerlink" title="2.弗洛伊德（Floyd）算法"></a>2.弗洛伊德（Floyd）算法</h4><h3 id="七-拓扑排序"><a href="#七-拓扑排序" class="headerlink" title="七.拓扑排序"></a>七.拓扑排序</h3><h4 id="1-拓扑排序算法"><a href="#1-拓扑排序算法" class="headerlink" title="1.拓扑排序算法"></a>1.拓扑排序算法</h4><h3 id="八-关键路径"><a href="#八-关键路径" class="headerlink" title="八.关键路径"></a>八.关键路径</h3><h4 id="1-关键路径算法原理"><a href="#1-关键路径算法原理" class="headerlink" title="1.关键路径算法原理"></a>1.关键路径算法原理</h4><h4 id="2-关键路径算法"><a href="#2-关键路径算法" class="headerlink" title="2.关键路径算法"></a>2.关键路径算法</h4> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-数据结构与算法(5)-树"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/01/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(5)-%E6%A0%91/"
    >数据结构与算法(5)-树</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/01/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(5)-%E6%A0%91/" class="article-date">
  <time datetime="2019-01-23T07:00:00.000Z" itemprop="datePublished">2019-01-23</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="一-树的定义"><a href="#一-树的定义" class="headerlink" title="一.树的定义"></a>一.树的定义</h3><h4 id="1-定义："><a href="#1-定义：" class="headerlink" title="1.定义："></a>1.定义：</h4><h5 id="1-树-Tree-是n-n≥0-个结点的有限集。n-0时称为空树"><a href="#1-树-Tree-是n-n≥0-个结点的有限集。n-0时称为空树" class="headerlink" title="(1)树(Tree)是n(n≥0)个结点的有限集。n=0时称为空树"></a>(1)树(Tree)是n(n≥0)个结点的有限集。n=0时称为空树</h5><h5 id="2-在任意一棵非空树中："><a href="#2-在任意一棵非空树中：" class="headerlink" title="(2)在任意一棵非空树中："></a>(2)在任意一棵非空树中：</h5><ul>
<li>有且仅有一个特定的称为根（Root）的结点；</li>
<li>当n＞1时，其余结点可分为m（m＞0）个互不相交的有限集T1、T2、……、Tm，其中每一个集合本身又是一棵树，并且称为根的子树</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LTViYjY0YjE5YzFlMTRhNDMucG5n?x-oss-process=image/format,png" alt="树"></p>
<h5 id="3-注意："><a href="#3-注意：" class="headerlink" title="(3)注意："></a>(3)注意：</h5><ul>
<li>n&gt;0时，根结点是唯一的</li>
<li>m&gt;0时，子树的个数没有限制，但它们一定是互不相交的</li>
</ul>
<h4 id="2-结点的分类"><a href="#2-结点的分类" class="headerlink" title="2.结点的分类"></a>2.结点的分类</h4><p>(1)树的结点包含一个数据元素及若干指向其子树的分支。<br>(2)结点拥有的子树数称为结点的度（De-gree）<br>(3)度为0的结点称为叶结点（Leaf）或终端结点；<br>(4)度不为0的结点称为非终端结点或分支结点。<br>(5)除根结点之外，分支结点也称为内部结点。<br>(6)树的度是树内各结点的度的最大值</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LWJhY2E3MjU1MjVhODNiN2MucG5n?x-oss-process=image/format,png" alt="结点分类"></p>
<h4 id="3-结点间的关系"><a href="#3-结点间的关系" class="headerlink" title="3.结点间的关系"></a>3.结点间的关系</h4><p>(1)结点的子树的根称为该结点的孩子（Child），相应地，该结点称为孩子的双亲（Parent）<br>(2)同一个双亲的孩子之间互称兄弟（Sibling）<br>(3)结点的祖先是从根到该结点所经分支上的所有结点<br>(4)以某结点为根的子树中的任一结点都称为该结点的子孙</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LTU3NDljZDkzMzlhZDBkNWEucG5n?x-oss-process=image/format,png" alt="结点间的关系"></p>
<h4 id="4-树的其他相关概念："><a href="#4-树的其他相关概念：" class="headerlink" title="4.树的其他相关概念："></a>4.树的其他相关概念：</h4><h5 id="1-结点的层次-Level"><a href="#1-结点的层次-Level" class="headerlink" title="(1)结点的层次(Level):"></a>(1)结点的层次(Level):</h5><p>从根开始定义起，根为第一层，根的孩子为第二层。若某结点在第l层，则其子树就在第l+1层。其双亲在同一层的结点互为堂兄弟。显然图6-2-6中的D、E、F是堂兄弟，而G、H、I与J也是堂兄弟。树中结点的最大层次称为树的深度(Depth)或高度</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LWQxOTdiOGRmMzliZWU5OTgucG5n?x-oss-process=image/format,png" alt="结点的层次"></p>
<h5 id="2-将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树"><a href="#2-将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树" class="headerlink" title="(2)将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树"></a>(2)将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树</h5><h5 id="3-森林（Forest）是m（m≥0）棵互不相交的树的集合"><a href="#3-森林（Forest）是m（m≥0）棵互不相交的树的集合" class="headerlink" title="(3)森林（Forest）是m（m≥0）棵互不相交的树的集合"></a>(3)森林（Forest）是m（m≥0）棵互不相交的树的集合</h5><h5 id="4-线性表与树的区别"><a href="#4-线性表与树的区别" class="headerlink" title="(4)线性表与树的区别"></a>(4)线性表与树的区别</h5><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LTE1YWQ2YWQxZDM2YTIxYjgucG5n?x-oss-process=image/format,png" alt="线性表与树的区别"></p>
<h3 id="二-树的抽象数据类型"><a href="#二-树的抽象数据类型" class="headerlink" title="二.树的抽象数据类型"></a>二.树的抽象数据类型</h3><h3 id="三-树的存储结构"><a href="#三-树的存储结构" class="headerlink" title="三.树的存储结构"></a>三.树的存储结构</h3><p>双亲表示法、孩子表示法、孩子兄弟表示法可以实现对树的存储结构的表示</p>
<h4 id="1-双亲表示法"><a href="#1-双亲表示法" class="headerlink" title="1.双亲表示法"></a>1.双亲表示法</h4><h4 id="2-孩子表示法"><a href="#2-孩子表示法" class="headerlink" title="2.孩子表示法"></a>2.孩子表示法</h4><h4 id="3-孩子兄弟表示法"><a href="#3-孩子兄弟表示法" class="headerlink" title="3.孩子兄弟表示法"></a>3.孩子兄弟表示法</h4><h3 id="四-二叉树的定义"><a href="#四-二叉树的定义" class="headerlink" title="四.二叉树的定义"></a>四.二叉树的定义</h3><h4 id="1-二叉树的特点："><a href="#1-二叉树的特点：" class="headerlink" title="1.二叉树的特点："></a>1.二叉树的特点：</h4><p>(1)每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。注意不是只有两棵子树，而是最多有。没有子树或者有一棵子树都是可以的</p>
<p>(2)左子树和右子树是有顺序的，次序不能任意颠倒。</p>
<p>(3)即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。如图所示，树1和树2是同一棵树，但它们却是不同的二叉树。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LTZkZWY3YTFmMjJlZjNiOWUucG5n?x-oss-process=image/format,png"></p>
<h4 id="2-二叉树具有5种基本形态："><a href="#2-二叉树具有5种基本形态：" class="headerlink" title="2.二叉树具有5种基本形态："></a>2.二叉树具有5种基本形态：</h4><p>(1).空二叉树<br>(2).只有一个根结点<br>(3).根结点只有左子树<br>(4).根结点只有右子树<br>(5).根结点既有左子树又有右子树”</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LTEyYWY0ZGVhOWRjZWEyNDYucG5n?x-oss-process=image/format,png" alt="二叉树形态"></p>
<h4 id="3-特殊二叉树"><a href="#3-特殊二叉树" class="headerlink" title="3.特殊二叉树"></a>3.特殊二叉树</h4><h5 id="1-斜树："><a href="#1-斜树：" class="headerlink" title="(1)斜树："></a>(1)斜树：</h5><p>所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树</p>
<h5 id="2-满二叉树："><a href="#2-满二叉树：" class="headerlink" title="(2)满二叉树："></a>(2)满二叉树：</h5><p>在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树</p>
<h6 id="a-满二叉树的特点有："><a href="#a-满二叉树的特点有：" class="headerlink" title="(a)满二叉树的特点有："></a>(a)满二叉树的特点有：</h6><ul>
<li>叶子只能出现在最下一层。出现在其他层就不可能达成平衡。</li>
<li>非叶子结点的度一定是2。</li>
<li>在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LWQ3YmIyNjdjOTBiMjY0NGMucG5n?x-oss-process=image/format,png" alt="满二叉树"></p>
<h5 id="3-完全二叉树："><a href="#3-完全二叉树：" class="headerlink" title="(3)完全二叉树："></a>(3)完全二叉树：</h5><p>对一棵具有n个结点的二叉树按层序编号，如果编号为i（1≤i≤n）的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LTQ4ZGY1ZWNlNTVjODI5MDUucG5n?x-oss-process=image/format,png" alt="完全二叉树"></p>
<ul>
<li>首先，满二叉树一定是一棵完全二叉树，但完全二叉树不一定是满的</li>
<li>其次，完全二叉树的所有结点与同样深度的满二叉树，它们按层序编号相同的结点，是一一对应的</li>
</ul>
<h6 id="a-完全二叉树的特点："><a href="#a-完全二叉树的特点：" class="headerlink" title="(a)完全二叉树的特点："></a>(a)完全二叉树的特点：</h6><ul>
<li>叶子结点只能出现在最下两层。</li>
<li>最下层的叶子一定集中在左部连续位置。</li>
<li>倒数二层，若有叶子结点，一定都在右部连续位置。</li>
<li>如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况。</li>
<li>同样结点数的二叉树，完全二叉树的深度最小”</li>
</ul>
<h3 id="五-二叉树的性质"><a href="#五-二叉树的性质" class="headerlink" title="五.二叉树的性质"></a>五.二叉树的性质</h3><h4 id="1-性质一"><a href="#1-性质一" class="headerlink" title="1.性质一"></a>1.性质一</h4><p>性质1:在二叉树的第i层上至多有2<sup>i-1</sup>个结点（i≥1）”</p>
<h4 id="2-性质二"><a href="#2-性质二" class="headerlink" title="2.性质二"></a>2.性质二</h4><p>性质2：深度为k的二叉树至多有2<sup>k</sup>-1个结点（k≥1）</p>
<h4 id="3-性质三"><a href="#3-性质三" class="headerlink" title="3.性质三"></a>3.性质三</h4><p>性质3：对任何一棵二叉树T，如果其终端结点数为n<sub>0</sub>，度为2的结点数为n<sub>2</sub>，则n<sub>0</sub>=n<sub>2</sub>+1。</p>
<h4 id="4-性质四"><a href="#4-性质四" class="headerlink" title="4.性质四"></a>4.性质四</h4><p>性质4：具有n个结点的完全二叉树的深度为|log<sub>2</sub>n+1|（|x|表示不大于x的最大整数）</p>
<h4 id="5-性质五"><a href="#5-性质五" class="headerlink" title="5.性质五"></a>5.性质五</h4><p>性质5：如果对一棵有n个结点的完全二叉树（其深度为i）的结点按层序编号（从第1层到第层，每层从左到右），对任一结点i（1≤i≤n）有：</p>
<ul>
<li>如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是结点。</li>
<li>如果2i&gt;n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子是结点2i。</li>
<li>如果2i+1&gt;n，则结点i无右孩子；否则其右孩子是结点2i+1。”</li>
</ul>
<h3 id="六-二叉树的存储结构"><a href="#六-二叉树的存储结构" class="headerlink" title="六.二叉树的存储结构"></a>六.二叉树的存储结构</h3><h4 id="1-二叉树顺序存储结构"><a href="#1-二叉树顺序存储结构" class="headerlink" title="1.二叉树顺序存储结构"></a>1.二叉树顺序存储结构</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LTVmZDE3NDY3NzU4ZWJhNTIucG5n?x-oss-process=image/format,png" alt="顺序存储结构"></p>
<h4 id="2-二叉链表"><a href="#2-二叉链表" class="headerlink" title="2.二叉链表"></a>2.二叉链表</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LTY4NTc4MzQzNTgxZTA2MjUucG5n?x-oss-process=image/format,png" alt="二叉链表结构示意图"></p>
<h3 id="七-遍历二叉树"><a href="#七-遍历二叉树" class="headerlink" title="七.遍历二叉树"></a>七.遍历二叉树</h3><h4 id="1-二叉树遍历原理"><a href="#1-二叉树遍历原理" class="headerlink" title="1.二叉树遍历原理"></a>1.二叉树遍历原理</h4><p>二叉树的遍历（traversing binary tree）是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次</p>
<h4 id="2-二叉树遍历方法："><a href="#2-二叉树遍历方法：" class="headerlink" title="2.二叉树遍历方法："></a>2.二叉树遍历方法：</h4><h5 id="1-前序遍历"><a href="#1-前序遍历" class="headerlink" title="(1)前序遍历"></a>(1)前序遍历</h5><p>规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。如图所示，遍历的顺序为：ABDGH-CEIF</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LTA4ODQwMmNjNzk1NzEwMmIucG5n?x-oss-process=image/format,png" alt="前序遍历"></p>
<p>前序遍历算法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二叉树的前序遍历递归算法 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == NULL)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* 显示结点数据，可以更改为其他对结点操作 */</span></span><br><span class="line">    printf(<span class="string">&quot;%c&quot;</span>, T-&gt;data);          </span><br><span class="line">    <span class="comment">/* 再先序遍历左子树 */</span></span><br><span class="line">    PreOrderTraverse(T-&gt;lchild);    </span><br><span class="line">    <span class="comment">/* 最后先序遍历右子树 */</span></span><br><span class="line">    PreOrderTraverse(T-&gt;rchild);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="(2)中序遍历"></a>(2)中序遍历</h5><p>规则是若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。如图所示，遍历的顺序为：GDHBAE-ICF</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LTM2MmJhZDJmYjAxODMzYzcucG5n?x-oss-process=image/format,png" alt="中序遍历"></p>
<p>中序遍历算法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二叉树的中序遍历递归算法 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == NULL)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* 中序遍历左子树 */</span></span><br><span class="line">    InOrderTraverse(T-&gt;lchild);    </span><br><span class="line">    <span class="comment">/* 显示结点数据，可以更改为其他对结点操作 */</span></span><br><span class="line">    printf(<span class="string">&quot;%c&quot;</span>, T-&gt;data);         </span><br><span class="line">    <span class="comment">/* 最后中序遍历右子树 */</span></span><br><span class="line">    InOrderTraverse(T-&gt;rchild);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="(3)后序遍历"></a>(3)后序遍历</h5><p>规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。如图所示，遍历的顺序为：GHDBIEFCA</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LTlmNzA2ZTNhODRjNzRiZTIucG5n?x-oss-process=image/format,png" alt="后序遍历"></p>
<p>后序遍历算法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二叉树的后序遍历递归算法 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == NULL)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* 先后序遍历左子树 */</span></span><br><span class="line">    PostOrderTraverse(T-&gt;lchild);    </span><br><span class="line">    <span class="comment">/* 再后序遍历右子树 */</span></span><br><span class="line">    PostOrderTraverse(T-&gt;rchild);    </span><br><span class="line">    <span class="comment">/* 显示结点数据，可以更改为其他对结点操作 */</span></span><br><span class="line">    printf(<span class="string">&quot;%c&quot;</span>, T-&gt;data);           </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h5 id="4-层序遍历："><a href="#4-层序遍历：" class="headerlink" title="(4)层序遍历："></a>(4)层序遍历：</h5><p>规则是若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。如图所示，遍历的顺序为：ABCDEFGHI </p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LWMzMzk4MzUzNzJiOTIxZGYucG5n?x-oss-process=image/format,png" alt="层序遍历"></p>
<h4 id="3-推导遍历结果："><a href="#3-推导遍历结果：" class="headerlink" title="3.推导遍历结果："></a>3.推导遍历结果：</h4><h5 id="1-二叉树遍历的两个性质："><a href="#1-二叉树遍历的两个性质：" class="headerlink" title="(1)二叉树遍历的两个性质："></a>(1)二叉树遍历的两个性质：</h5><ul>
<li>已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。</li>
<li>已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。</li>
</ul>
<h5 id="2-已知前序和后序遍历，是不能确定一棵二叉树的"><a href="#2-已知前序和后序遍历，是不能确定一棵二叉树的" class="headerlink" title="(2)已知前序和后序遍历，是不能确定一棵二叉树的"></a>(2)已知前序和后序遍历，是不能确定一棵二叉树的</h5><h3 id="八-二叉树的建立"><a href="#八-二叉树的建立" class="headerlink" title="八.二叉树的建立"></a>八.二叉树的建立</h3><h4 id="1-代码"><a href="#1-代码" class="headerlink" title="1.代码"></a>1.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 按前序输入二叉树中结点的值（一个字符） */</span></span><br><span class="line"><span class="comment">/* #表示空树，构造二叉链表表示二叉树T。 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TElemType ch;</span><br><span class="line">    scanf(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">      *T = NULL;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *T = (BiTree)malloc(sizeof(BiTNode));</span><br><span class="line">        <span class="keyword">if</span> (!*T)</span><br><span class="line">            exit(OVERFLOW);</span><br><span class="line">        <span class="comment">/* 生成根结点 */</span></span><br><span class="line">        (*T)-&gt;data = ch;                </span><br><span class="line">        <span class="comment">/* 构造左子树 */</span></span><br><span class="line">        CreateBiTree(&amp;(*T)-&gt;lchild);    </span><br><span class="line">        <span class="comment">/* 构造右子树 */</span></span><br><span class="line">        CreateBiTree(&amp;(*T)-&gt;rchild);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="九-线索二叉树"><a href="#九-线索二叉树" class="headerlink" title="九.线索二叉树"></a>九.线索二叉树</h3><h4 id="1-线索二叉树原理"><a href="#1-线索二叉树原理" class="headerlink" title="1.线索二叉树原理"></a>1.线索二叉树原理</h4><h4 id="2-线索二叉树结构实现"><a href="#2-线索二叉树结构实现" class="headerlink" title="2.线索二叉树结构实现"></a>2.线索二叉树结构实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二叉树的二叉线索存储结构定义 */</span></span><br><span class="line"><span class="comment">/* Link==0表示指向左右孩子指针 */</span></span><br><span class="line"><span class="comment">/* Thread==1表示指向前驱或后继的线索 */</span></span><br><span class="line">typedef <span class="class"><span class="keyword">enum</span> </span>&#123;Link, Thread&#125; PointerTag;    </span><br><span class="line"><span class="comment">/* 二叉线索存储结点结构 */</span></span><br><span class="line">typedef struct BiThrNode                   </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 结点数据 */</span></span><br><span class="line">    TElemType data;                        </span><br><span class="line">    <span class="comment">/* 左右孩子指针 */</span></span><br><span class="line">    struct BiThrNode *lchild, *rchild;     </span><br><span class="line">    PointerTag LTag;</span><br><span class="line">    <span class="comment">/* 左右标志 */</span></span><br><span class="line">    PointerTag RTag;                       </span><br><span class="line">&#125; BiThrNode, *BiThrTree;” </span><br></pre></td></tr></table></figure>

<h4 id="3-中序遍历线索二叉树"><a href="#3-中序遍历线索二叉树" class="headerlink" title="3.中序遍历线索二叉树"></a>3.中序遍历线索二叉树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">BiThrTree pre;                     <span class="comment">/* 全局变量，始终指向刚刚访问过的结点 */</span></span><br><span class="line"><span class="comment">/* 中序遍历进行中序线索化 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThreading</span><span class="params">(BiThrTree p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 递归左子树线索化 */</span></span><br><span class="line">        InThreading(p-&gt;lchild);    </span><br><span class="line">        <span class="comment">/* 没有左孩子 */</span></span><br><span class="line">        <span class="keyword">if</span> (!p-&gt;lchild)            </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 前驱线索 */</span></span><br><span class="line">            p-&gt;LTag = Thread;      </span><br><span class="line">            <span class="comment">/* 左孩子指针指向前驱 */</span></span><br><span class="line">            p-&gt;lchild = pre;       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 前驱没有右孩子 */</span></span><br><span class="line">        <span class="keyword">if</span> (!pre-&gt;rchild)          </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 后继线索 */</span></span><br><span class="line">            pre-&gt;RTag = Thread;    </span><br><span class="line">            <span class="comment">/* 前驱右孩子指针指向后继（当前结点p） */</span></span><br><span class="line">            pre-&gt;rchild = p;       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 保持pre指向p的前驱 */</span></span><br><span class="line">        pre = p;                   </span><br><span class="line">        <span class="comment">/* 递归右子树线索化 */</span></span><br><span class="line">        InThreading(p-&gt;rchild);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="十-树，二叉树，森林之间的转换"><a href="#十-树，二叉树，森林之间的转换" class="headerlink" title="十.树，二叉树，森林之间的转换"></a>十.树，二叉树，森林之间的转换</h3><h4 id="1-树转换为二叉树步骤："><a href="#1-树转换为二叉树步骤：" class="headerlink" title="1.树转换为二叉树步骤："></a>1.树转换为二叉树步骤：</h4><p>(1)加线。在所有兄弟结点之间加一条连线。<br>(2)去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线。<br>(3)层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LWE5ZmVlNjI2NTk2ZDNmOTkucG5n?x-oss-process=image/format,png" alt="树-&gt;二叉树"></p>
<h4 id="2-森林转换为二叉树步骤："><a href="#2-森林转换为二叉树步骤：" class="headerlink" title="2.森林转换为二叉树步骤："></a>2.森林转换为二叉树步骤：</h4><p>(1).把每个树转换为二叉树</p>
<p>(2).第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。当所有的二叉树连接起来后就得到了由森林转换来的二叉树</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LWVmMmJmNjY3ZjczOTQ0OTYucG5n?x-oss-process=image/format,png" alt="森林-&gt;二叉树"></p>
<h4 id="3-二叉树转化为树步骤："><a href="#3-二叉树转化为树步骤：" class="headerlink" title="3.二叉树转化为树步骤："></a>3.二叉树转化为树步骤：</h4><p>(1).加线。若某结点的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点……，反正就是左孩子的n个右孩子结点都作为此结点的孩子。将该结点与这些右孩子结点用线连接起来。 </p>
<p>(2).去线。删除原二叉树中所有结点与其右孩子结点的连线。</p>
<p>(3).层次调整。使之结构层次分明</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LTg3ZDk1NzZiYzg5MTU5NjAucG5n?x-oss-process=image/format,png" alt="二叉树-&gt;树"></p>
<h4 id="4-二叉树转化为森林步骤："><a href="#4-二叉树转化为森林步骤：" class="headerlink" title="4.二叉树转化为森林步骤："></a>4.二叉树转化为森林步骤：</h4><p>(1).从根结点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除……，直到所有右孩子连线都删除为止，得到分离的二叉树。 </p>
<p>(2).再将每棵分离后的二叉树转换为树即可</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MzkxNDA3LTMxZDU1MDU3ODNiNjk5OGQucG5n?x-oss-process=image/format,png" alt="二叉树-&gt;森林"></p>
<h4 id="5-树与森林的遍历"><a href="#5-树与森林的遍历" class="headerlink" title="5.树与森林的遍历"></a>5.树与森林的遍历</h4><h5 id="1-树的遍历分为两种方式"><a href="#1-树的遍历分为两种方式" class="headerlink" title="(1)树的遍历分为两种方式"></a>(1)树的遍历分为两种方式</h5><ul>
<li>一种是先根遍历树，即先访问树的根结点，然后依次先根遍历根的每棵子树</li>
<li>另一种是后根遍历，即先依次后根遍历每棵子树，然后再访问根结点</li>
</ul>
<h5 id="2-森林的遍历也分为两种方式："><a href="#2-森林的遍历也分为两种方式：" class="headerlink" title="(2)森林的遍历也分为两种方式："></a>(2)森林的遍历也分为两种方式：</h5><ul>
<li>前序遍历：先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林</li>
<li>后序遍历：是先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/22/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="page-number" href="/page/22/">22</a><span class="page-number current">23</span><a class="page-number" href="/page/24/">24</a><a class="page-number" href="/page/25/">25</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/24/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2021
        <i class="ri-heart-fill heart_icon"></i> Movle
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="https://img-blog.csdnimg.cn/20200609161448519.jpg" alt="Movle"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>